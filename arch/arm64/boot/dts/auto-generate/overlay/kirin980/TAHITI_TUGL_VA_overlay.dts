/**
 * Copyright (C) 2014 Hisilicon Ltd.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License version 2 as
 *  publishhed by the Free Software Foundation.
 */

/dts-v1/;
/plugin/;
/include/ "TAHITI_TUGL_VA_pin.dtsi"
/include/ "TAHITI_TUGL_VA_modem_pin.dtsi"
/include/ "TAHITI_TUGL_VA_hi6402_pin.dtsi"
/include/ "huawei_audio_dto.dtsi"
/include/ "huawei_hall_inputhub_dto.dtsi"
/include/ "usb_short_circuit_protect_dto.dtsi"
/include/ "huawei_pmucurr_test_dto.dtsi"
/include/ "sunwodaatl_2220_snIA_4400.dtsi"
/include/ "sunwodaatl_2220_snIA_4430.dtsi"
/include/ "hi11xx_connectivity_dto.dtsi"
/include/ "lcdkit3.0/default/devkit_lcd_kit.dtsi"
/include/ "lcdkit3.0/tahiti_tugl/devkit_lcd_kit.dtsi"
/include/ "batt_acr_detect_dto.dtsi"

/ {
    board_id = <8520>;
};
	&rootparam{
		compatible = "hisilicon,vendor";
		hisi,boardid = <8 5 2 0>;
		hisi,boardname = "TAHITI_TUGL_VA";
		hisi,modem_id = <0x37030000>;
		hisi,product_id = <0x37030000>;
		hisi,product_name = "TAH-AL00";
	};
&hisi_peripheral_tm {
    compatible = "hisi,hisi-peripheral-tm";
    hisi,peripheral_sensors = <11>;

    hisi,detect_system_h_tm_chanel = <7>;
    hisi,detect_system_h_tm_ntc = "austin_hkadc_soc_temp_table";
    hisi,detect_system_h_tm_state = "enable";
    hisi,detect_system_h_throttling = <53>;
    hisi,detect_system_h_shutdown = <55>;
    hisi,detect_system_h_below_vr_min = <53>;
    hisi,detect_system_h_over_skin = <12>;

    hisi,detect_flash_led_tm_chanel = <3>;
    hisi,detect_flash_led_tm_ntc = "austin_hkadc_soc_temp_table";
    hisi,detect_flash_led_tm_state = "disable";

    hisi,detect_charger_tm_chanel = <4>;
    hisi,detect_charger_tm_ntc = "austin_hkadc_soc_temp_table";
    hisi,detect_charger_tm_state = "enable";

    hisi,detect_pa_0_tm_chanel = <5>;
    hisi,detect_pa_0_tm_ntc = "austin_hkadc_pa_temp_table";
    hisi,detect_pa_0_tm_state = "enable";

    hisi,detect_pa_1_tm_chanel = <6>;
    hisi,detect_pa_1_tm_ntc = "austin_hkadc_pa_temp_table";
    hisi,detect_pa_1_tm_state = "enable";

    hisi,detect_dcxo0_tm_chanel = <15>;
    hisi,detect_dcxo0_tm_ntc = "austin_hkadc_adc_temp_table";
    hisi,detect_dcxo0_tm_state = "enable";

    hisi,detect_shell_tm_chanel = <7>;
    hisi,detect_shell_tm_ntc = "austin_hkadc_soc_temp_table";
    hisi,detect_shell_tm_state = "disable";

    hisi,detect_charger1_tm_chanel = <4>;
    hisi,detect_charger1_tm_ntc = "austin_hkadc_soc_temp_table";
    hisi,detect_charger1_tm_state = "disable";

    hisi,detect_usb_tm_chanel = <3>;
    hisi,detect_usb_tm_ntc = "austin_hkadc_soc_temp_table";
    hisi,detect_usb_tm_state = "enable";

    hisi,detect_rfboard_tm_chanel = <8>;
    hisi,detect_rfboard_tm_ntc = "austin_hkadc_soc_temp_table";
    hisi,detect_rfboard_tm_state = "enable";

    hisi,detect_wireless_tm_chanel = <12>;
    hisi,detect_wireless_tm_ntc = "austin_hkadc_soc_temp_table";
    hisi,detect_wireless_tm_state = "disable";

    status = "ok";
};

&hisi_mdm_temp {
                    compatible = "hisi,mdm_temp";
                    status = "ok";
                    sensors {
                        sensor0 {
                            type = "mmw_0";
                            channel = <13>;
                            mode = <1>;
                            tm_ntc_table = "austin_hkadc_soc_temp_table";
                        };
                        sensor1 {
                            type = "mmw_1";
                            channel = <7>;
                            mode = <1>;
                            tm_ntc_table = "austin_hkadc_soc_temp_table";
                        };
                        sensor2 {
                            type = "pa_2";
                            channel = <4>;
                            mode = <1>;
                            tm_ntc_table = "austin_hkadc_soc_temp_table";
                        };
                        sensor3 {
                            type = "pa_3";
                            channel = <9>;
                            mode = <1>;
                            tm_ntc_table = "austin_hkadc_soc_temp_table";
                        };
                        sensor4 {
                            type = "pa_4";
                            channel = <12>;
                            mode = <1>;
                            tm_ntc_table = "austin_hkadc_soc_temp_table";
                        };
                        sensor5 {
                            type = "mdm_soc0";
                            channel = <16>;
                            mode = <1>;
                            tm_ntc_table = "none";
                        };
                        sensor6 {
                            type = "mdm_soc1";
                            channel = <17>;
                            mode = <1>;
                            tm_ntc_table = "none";
                        };
                        sensor7 {
                            type = "mdm_soc2";
                            channel = <18>;
                            mode = <1>;
                            tm_ntc_table = "none";
                        };
                        sensor8 {
                            type = "mdm_soc3";
                            channel = <19>;
                            mode = <1>;
                            tm_ntc_table = "none";
                        };
                        sensor9 {
                            type = "mdm_ddr";
                            channel = <20>;
                            mode = <1>;
                            tm_ntc_table = "none";
                        };
                    };

        };

&hisi_shell {
    compatible = "hisi,shell-temp";
    interval = <5000>;
    bias = <0>;
    count = <6>;
    status = "ok";
    sensors {
        sensor0 {
            type = "system_h";
            coef = "0","0","0","0","0","0";
        };
        sensor1 {
            type = "charger";
            coef = "0","0","0","0","0","0";
        };
        sensor2 {
            type = "pa_0";
            coef = "0","0","0","0","0","0";
        };
        sensor3 {
            type = "dcxo0";
            coef = "0","0","0","0","0","0";
        };
    };
};

&hisi_ambient {
    compatible = "hisi,ambient-temp";
    interval = <900>;
    bias = <1>;
    status = "ok";
    sensors {
        sensor0 {
            type = "system_h";
        };
        sensor1 {
            type = "charger";
        };
        sensor2 {
            type = "pa_0";
        };
        sensor3 {
            type = "dcxo0";
        };
    };
};

&fastboot_pmic {
	hisilicon,init-reg-num = <3>;
	hisilicon,init-reg-addrs = <0x18C 0x3DA 0x02E9>;
	hisilicon,init-reg-vals  = <0x1 0x54 0x06>;
};

	&chosen {};
	
    &rdr {
         rdr-log-max-size = <0x30000000>; 
    };
	
	&hisi_ion {
		heap_sec_drm@20 {
			status = "disabled";
		};
	};

	&spmi {
		pmic@0 {
			gpios = <&gpio22 1 0>;
			hisilicon,pmic_fpga_flag=<0>;
				pmic_led@a0 {
					status = "ok";
					led@a0 {  /*red*/
						hisilicon,each_max_iset = <0x2>;
					};
					led@a1 {  /*green*/
						hisilicon,each_max_iset = <0x0>;
					};
					led@a2 {  /*blue*/
						hisilicon,each_max_iset = <0x0>;
					};
				};
				pmic_rtc@a0 {
					status = "ok";
				};
				ponkey@b1{
		           		status = "ok";
				};
				pmic_mntn@a0 {
					status = "ok";
					OCP@2B9 {
						compatible = "hisilicon-pmic-mntn-ocp-reg0x2B9";
						hisilicon,inacceptable-event = <0xFF>;
						hisilicon,check_ocp_reset = <0x00>;
						hisilicon,check_ocp_nofify = <0xC5>;
						hisilicon,check_ocp_num = <0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x3>;
						hisilicon,event-bit-name = "ldo32","ldo30","ldo29","ldo28","ldo27","ldo26","ldo25","ldo24";
						hisilicon,event-ops-reg = <0x32 0x31 0x30 0x2F 0x2E 0x2D 0x2C 0x2B>;
					};
				};
				hi6421v700_coul@1 {
					status = "ok";
                                };
				pmic_vibrator {
					status = "ok";
					hisi_pmic_vibrator,max-timeout-ms = <10000>;
					hisi_pmic_vibrator,label = "vibrator";
					vibrator-reg-on = <0xA000>;
					vibrator-reg-off = <0xA001>;
					vibrator-voltage = <1400>;
					vibrator-boost-power = <1>; //0:not used 5v,1 used
					haptics-cfg =
						<0x00 0x00 0x08 0x0f 0x10 0x00 0x18 0x0f 0x1f 0x00 0x26 0x0f 0x2d 0x00 0x32 0x0f 0x37 0x00 0x3b 0x0f 0x3d 0xc0 0x3f 0x0d 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00>,//6 cycle
						<0x00 0x00 0x08 0x0f 0x10 0x00 0x18 0x0f 0x1f 0x00 0x26 0x0f 0x2d 0x00 0x32 0x0f 0x37 0x00 0x3b 0x0f 0x3d 0x00 0x3f 0x0f 0x40 0x00 0x40 0x0f 0x40 0xf0 0x40 0x07 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00>,//8 cycle
						<0x00 0x00 0x08 0x0f 0x10 0x00 0x18 0x0f 0x1f 0x00 0x26 0x0f 0x2d 0x00 0x32 0x0f 0x37 0x00 0x3b 0x0f 0x3d 0x00 0x3f 0x0f 0x40 0x00 0x40 0x0f 0x40 0x00 0x40 0x0f 0x40 0x00 0x40 0x0f 0x40 0xf0 0x40 0x07>,//10 cycle
						<0x00 0x40 0x08 0x0b 0x10 0x40 0x18 0x0b 0x1f 0x40 0x26 0x0b 0x2d 0x40 0x32 0x0b 0x37 0x40 0x3b 0x0b 0x3d 0x50 0x3f 0x0a 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00>,//%75 6 cycle
						<0x00 0x80 0x08 0x07 0x10 0x80 0x18 0x07 0x1f 0x80 0x26 0x07 0x2d 0x80 0x32 0x07 0x37 0x80 0x3b 0x07 0x3d 0x40 0x3f 0x06 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00 0x40 0x00>;//%50 6 cycle
				};

			ldo22@29 {
				compatible = "hisilicon-hisi-ldo";
				regulator-name = "ldo22";
				regulator-min-microvolt = <950000>;
				regulator-max-microvolt = <1200000>;
				hisilicon,hisi-ctrl = <0x29 0x01 0x00>;
				hisilicon,hisi-vset = <0x6C 0x0F>;
				hisilicon,hisi-n-voltages = <16>;
				hisilicon,hisi-vset-table = <950000>, <1010000>,
											<1020000>, <1030000>,
											<1040000>, <1050000>,
											<1060000>, <1070000>,
											<1080000>, <1090000>,
											<1100000>, <1110000>,
											<1120000>, <1130000>,
											<1140000>, <1200000>;
				hisilicon,hisi-off-on-delay-us = <20000>;
				hisilicon,hisi-enable-time-us = <100>;
				hisilicon,hisi-eco-microamp = <10000>;
				hisilicon,valid-modes-mask = <0x02>;
				hisilicon,valid-idle-mask = <0x09>;
				status = "ok";
			};

			ldo34@33 {
				compatible = "hisilicon-hisi-ldo";
				regulator-name = "ldo34";
				regulator-always-on;
				regulator-min-microvolt = <2600000>;
				regulator-max-microvolt = <3300000>;
				hisilicon,hisi-ctrl = <0x33 0x01 0x10>;
				hisilicon,hisi-vset = <0x76 0x07>;
				hisilicon,hisi-n-voltages = <8>;
				hisilicon,hisi-vset-table = <2900000>, <2800000>,
				                            <2700000>, <2600000>,
				                            <3300000>, <3200000>,
				                            <3100000>, <3000000>;
				hisilicon,hisi-off-on-delay-us = <20000>;
				hisilicon,hisi-enable-time-us = <360>;
				hisilicon,hisi-eco-microamp = <10000>;
				hisilicon,valid-modes-mask = <0x06>;
				hisilicon,valid-idle-mask = <0x0D>;
				status = "ok";
			};
			ldo12@22 {
				compatible = "hisilicon-hisi-ldo";
				regulator-name = "ldo12";
				regulator-min-microvolt = <1625000>;
				regulator-max-microvolt = <3300000>;
				hisilicon,hisi-ctrl = <0x22 0x01 0x10>;
				hisilicon,hisi-vset = <0x65 0x0F>;
				hisilicon,hisi-n-voltages = <16>;
				hisilicon,hisi-vset-table = <1625000>, <1650000>,
				                            <1750000>, <1775000>,
				                            <1800000>, <1825000>,
				                            <1900000>, <2000000>,
				                            <2650000>, <2700000>,
				                            <2800000>, <2850000>,
				                            <2950000>, <3000000>,
				                            <3250000>, <3300000>;
				hisilicon,hisi-off-on-delay-us = <20000>;
				hisilicon,hisi-enable-time-us = <360>;
				hisilicon,hisi-eco-microamp = <10000>;
				hisilicon,valid-modes-mask = <0x06>;
				hisilicon,valid-idle-mask = <0x0D>;
				status = "ok";
			};
		};
	};

	&boost_5v {
		boost_5v_use_common_pmic = <1>;
		status = "ok";
	};

	&hisi_vibrator {
		status = "disabled";
	};

	&fastboot_battery {
		iin_limit_usb = <475>;
		iin_limit_ac = <2000>;
		ichrg_limit_ac = <1500>;
		status = "ok";
	};
	&fastboot_charger {
		charger_cd = <135>;
		hw_charger_type = <10>;
		chip_i2c_num = <6>;
		status = "ok";
	};
	&hisi_battery {
		batt_name = <&sunwodaatl_2220_snIA_4400 &sunwodaatl_2220_snIA_4430>;
		status = "ok";
	};
	&sunwodaatl_2220_snIA_4400 {
		temp_para =
			"-32767","0","-1","0","4100","0",
			"0","5","-1","-1","4400","0",
			"5","10","-1","-1","4400","3",
			"10","45","-1","-1","4400","3",
			"45","60","-1","-1","4400","3",
			"60","32767","-1","0","4400","0";
	};
	&sunwodaatl_2220_snIA_4430 {
		temp_para =
			"-32767","0","-1","0","4100","0",
			"0","5","-1","-1","4430","0",
			"5","10","-1","-1","4430","3",
			"10","45","-1","-1","4430","3",
			"45","60","-1","-1","4430","3",
			"60","32767","-1","0","4430","0";
	};
	&hisi_bci_battery {
		battery_design_fcc = <3650>;
		battery_board_type = <2>; /*0:sft 1:udp 2:asic*/
		status = "ok";
	};
	&coul_core {
		adc_batt_id = <11>;
		adc_batt_temp = <11>;
		r_coul_mohm = <2>;
		last_soc_enable = <1>;
		startup_delta_soc = <5>;
		soc_at_term = <97>;
		iscd_enable = <1>;
		ntc_compensation_is = <1>;
		ntc_temp_compensation_para =
			"4000", "50",
			"3000", "30",
			"2000", "20";
		basp_policy = <
			3 100000 60  200 200 60  0 920001032
			2 70000 80  40  50  80  0 920001031
			1 40000 90  20  0   90  0 920001029
			0 0     0   0   0   100 0 0
		>;
		normal_cutoff_vol_mv = <3000>;
		sleep_cutoff_vol_mv = <3200>;
		status = "ok";
	};
	&hisi_coul_drv_test {
		status = "ok";
	};
	&hw_pmucurr_test {
		power_numbers = <2>;
		status = "ok";
	};
	&huawei_charger {
		pd_support = <1>;
		support_usb_nonstandard_ico = <1>;
		support_standard_ico = <0>;
		ico_all_the_way = <0>;
		water_check_enabled = <1>;
		fcp_vindpm = <8100>;
		charge_done_sleep_enabled;
		leak_current_check = <1>;
		status = "ok";
	};
	&charging_core {
		status = "ok";
		iterm = <146>;
		iin_usb = <475>;
		ichg_usb = <500>;
		ichg_fcp = <1500>;
		iin_fcp = <2000>;
		ichg_ac = <1500>;
		iin_ac = <2000>;
		inductance_para =
			"-32767", "15", "1900", "0",
			"15", "32767", "1900", "0";
	};
	&ltc7820 {
		gpio_en = <&gpio21 1 0>;
		gpio_freq = <&gpio31 7 0>;
		gpio_int = <&gpio23 2 0>;
		status = "ok";
	};
	&direct_charge_ps {
		boost_5v_support_scp_power = <1>;
		bst_ctrl_use_common_gpio = <0>;
		bst_ctrl = <&gpio27 4 0>;
		is_need_bst_ctrl = <1>;
		status = "ok";
	};

	&direct_charger {
		use_5A = <1>;
		max_adaptor_vset = <11000>;
		init_adapter_vset = <8800>;
		init_delt_vset = <400>;
		volt_para =
			"4300", "4000", "3250",
			"4330", "3250", "2170",
			"4400", "2170", "800";
		compensate_r = <0>;
		cc_cable_detect_enable = <1>;
		full_path_res_max = <600>;
		scp_work_on_charger = <0>;
		standard_cable_full_path_res_max = <600>;
		super_ico_current = <2000>;
		is_show_ico_first = <1>;
		first_cc_stage_timer_in_min = <8>;
		stage_need_to_jump = "1";
		adaptor_detect_by_voltage = <1>;
		temp_para =
			"-32767", "10", "0",
			"10", "60", "4000",
			"60", "32767", "0";
		status = "ok";
	};

        &direct_charger_sc {
		use_8A = <1>;
		dc_volt_ratio = <2>;
		max_adaptor_vset = <20000>;
		init_adapter_vset = <17600>;
		delta_err = <200>;
		vol_err_th = <500>;
		adaptor_leakage_current_th = <600>;
		init_delt_vset = <600>;
		vstep = <40>;
		max_dc_bat_vol = <4380>;
		max_current_for_none_standard_cable = <5500>;
		super_ico_current = <2000>;
		is_show_ico_first = <1>;
		volt_para =
			"4200", "5500", "4340",
			"4300", "4340", "3250",
			"4330", "3250", "2170",
			"4400", "2170", "800";
		compensate_r = <0>;
		cc_cable_detect_enable = <1>;
		full_path_res_max = <600>;
		scp_work_on_charger = <0>;
		standard_cable_full_path_res_max = <600>;
		first_cc_stage_timer_in_min = <5>;
		stage_need_to_jump = "-1";
		adaptor_detect_by_voltage = <1>;
		temp_para =
			"-32767", "10", "0",
			"10", "60", "5500",
			"60", "32767", "0";
		status = "ok";
	};
	&dual_loadswitch {
		status = "ok";
	};
	&wired_channel_switch {
		use_ovp_cutoff_wired_channel = <1>;
		use_super_switch_cutoff_wired_channel = <0>;
		use_wireless_switch_cutoff_wired_channel = <0>;
		status = "ok";
	};
	&ovp_channel_switch {
		gpio_ovp_chsw_en = <&gpio31 3 0>;
		status = "ok";
	};

	&tps62180 {
		gpio_en = <&gpio2 1 0>;
		gpio_vout_ctrl = <&gpio5 7 0>;
		status = "ok";
	};

	&vsys_switch {
		vbatt_th = <7500>;
		vbatt_base = <7000>;
		vbatt_gap = <200>;
		compensate_res = <140>;
		dischg_curr_max = "2000";
		rbatt_sf_rows = <11>;
		rbatt_sf_cols = <11>;
		rbatt_sf_soc = <0 10 20 30 40 50 60 70 80 90 100>;
		rbatt_sf_temp = "25","20","15","10","5","0","-5","-10","-15","-20","-32767";
		rbatt_sf_sf = <
			100 100 100 100 100 100 100 100 100 100 100
			100 100 100 100 100 100 100 100 100 100 100
			100 100 100 100 100 100 100 100 100 100 100
			100 100 100 100 100 100 100 100 100 100 100
			125 125 125 125 125 125 125 125 125 125 125
			125 125 125 125 125 125 125 125 125 125 125
			235 235 235 235 235 235 235 235 235 235 235
			235 235 235 235 235 235 235 235 235 235 235
			450 450 450 450 450 450 450 450 450 450 450
			450 450 450 450 450 450 450 450 450 450 450
			450 450 450 450 450 450 450 450 450 450 450
		>;
		rbatt_aging_para =
			"700","13",
			"400","11",
			"0",  "10";
		status = "ok";
	};

	&huawei_smpl {
		status = "ok";
	};

	&vbat_ovp {
		status = "disabled";
	};

	&usb_short_circuit_protect {
		gpio_usb_short_circuit_protect = <&gpio16 6 0>;
		uscp_threshold_tusb = <50>;
		status = "ok";
	};

	&power_thermalzone {
		status = "ok";
		sensors{
			sensor0{
				sensor_name = "usb_port";
				ops_name = "hisi_adc";
				adc_channel = <3>;
				ntc_index = <1>;
			};
			sensor1{
				sensor_name = "bat_0";
				ops_name = "hisi_adc";
				adc_channel = <11>;
				ntc_index = <3>;
			};
			sensor2{
				sensor_name = "bat_1";
				ops_name = "hisi_adc";
				adc_channel = <10>;
				ntc_index = <3>;
			};
		};
	};
	&vbat_hkadc {
		status = "ok";
		adc_channel = <12>;
		coef = <1328>;
		r_pcb = <26000>;
	};
	&hw_batt_vol {
		status = "ok";
		batt_series_num = <2>;
		batt_vol{
			batt_vol0{
				batt_id = <0>;
				ops_name = "hisi_coul";
			};
			batt_vol1{
				batt_id = <1>;
				ops_name = "hisi_hkadc";
			};
			batt_vol2{
				batt_id = <2>;
				ops_name = "bq25882";
			};
		};
	};
	&huawei_battery_temp {
		status = "ok";
		ntc_compensation_is = <1>;
		battery_temp_high = <40000>;
		battery_temp_low = <15000>;
		ntc_temp_compensation_para =
			"5000", "12000",
			"4000", "7000",
			"3000", "4000",
			"2000", "2000";
	};
	&battery_balance {
		status = "ok";
		gpio_bat1_balance_en = <&gpio6 3 0>;
		gpio_bat0_balance_en = <&gpio21 2 0>;
	};
	&series_batt_charger {
		status = "ok";
		ircomp_r = <120>;
		ircomp_i_max = <1000>;
		ircomp_i_min = <200>;
	};
	&pd_dpm {
		switch_manual_enable = <0>;
		abnormal_cc_detection = <1>;
		status = "ok";
	};

	&huawei_usb {
		maximum-speed = "super-speed";
		usb_phy_ldo_33v-supply = <&ldo23>;
		status = "ok";
	};

	&fastboot {
		compatible = "hisilicon,fastboot";
		i2c3-pin = <0>;
		gpio-keyup = <213>;
		gpio-keydown = <210>;
		uart-board-type = <1>;
		/*UDP_TYPE 0,PRODUCT 1,FPGA 2,EMU 3*/
		lpm3-board-type = <0>;
		jtagtosd-board-type = <2>;
		motor-vib_type = <0>;

		i2c-select = <1>;
		i2c-sel0-gpio = <164>;
		i2c-sel1-gpio = <165>;
		i2c-sel0-val = <0>;
		i2c-sel1-val = <0>;
	};

	&pmu {
		compatible = "hisilicon,pmu";
		reg = <0x00 0xFFF34000 0x00 0x1000>;
		status = "ok";
	};

	&hisi_ipc {

	};
	&hisi_ao_ipc {

	};

        &hisi_sysctrl {
                compatible = "hisilicon,sysctrl";
                reg = <0x0 0xfff0a000 0x0 0x1000>;
                status = "ok";
        };

        &hisi_pctrl {
                compatible = "hisilicon,pctrl";
                reg = <0x0 0xe8a09000 0x0 0x1000>;
                status = "ok";
        };

        &hisi_crgctrl {
                compatible = "hisilicon,crgctrl";
                reg = <0x0 0xfff35000 0x0 0x1000>;
                status = "ok";
        };

	&hisi_iomcuctrl {
                compatible = "hisilicon,iomcuctrl";
                reg = <0x0 0xFFD7e000 0x0 0x1000>;
                status = "ok";
        };

        &hisi_pmctrl {
                compatible = "hisilicon,pmctrl";
                reg = <0x0 0xfff31000 0x0 0x1000>;
                status = "ok";
        };

        &hisi_mmc1_sysctrl {
                compatible = "hisilicon,mmc1_sysctrl";
                reg = <0x0 0xfc186000 0x0 0x1000>;
                status = "ok";
        };

        &hisi_media1ctrl {
                compatible = "hisilicon,media1ctrl";
                reg = <0x0 0xE87FF000 0x0 0x1000>;
                status = "ok";
        };

        &hisi_media2ctrl {
                compatible = "hisilicon,media2ctrl";
                reg = <0x0 0xE8900000 0x0 0x1000>;
                status = "ok";
        };
	&kirin_pcie_rc {
		/* LTR latency param comes from EP: BCM43596 -- 0x10031003 */
		ep_ltr_latency = <0x10031003>;

		/* T-poweron comes from EP: BCM43596 -- 0x10031003 */
		ep_l1ss_ctrl2 = <0x61>;

		/* the lower_16(l1ss_ctrl1) 0x370F needed by RC and must be set; the upper_16 comes from EP*/
		l1ss_ctrl1 = <0x4004370F>;

		/* Delay time come from BCM43596 powerup sequence */
		t_ref2perst = <21000 23000>;
		t_perst2access = <7000 8000>;
		t_perst2rst = <10000 11000>;
	};


	&kirin_pcie_ep {
	};

	&jtagtosd {
	    switch_ldo = <&ldo16>;
	};
	&hisi_axierr {
	        compatible = "hisi,hi3xxx-axi";
	        interrupts = <0 23 4>, <0 1 4>;
	        status = "ok";
        };

    &hisi_reset {
            compatible = "hisilicon,hi3xxx-reset";
            status = "ok";
        };

	&peripherals {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges = <0x0 0x00000000 0x0 0xffffffff>;

		clk6250khz {
			compatible = "fixed-clock";
			#clock-cells = <0>;
			clock-frequency = <6297600>;
			clock-output-names = "clk6250khz";
		};
/*
		clk4800khz {
			compatible = "fixed-clock";
			#clock-cells = <0>;
			clock-frequency = <32768>;
			clock-output-names = "clk4800khz";
		};
*/

		dma@fdf30000 {
			status = "ok";
		};
	};

	&maxim_ioctl {
		compatible = "huawei,maxim_ioctl";
		status = "ok";
	};

	&nve_uartctl {
		compatible = "hisilicon,hisi-uartctl";
		uartctl = "0000060F0F0F0F0F0F0F0F0F0F";
	};
	&amba {
		#address-cells = <2>;
		#size-cells = <2>;
		compatible = "arm,amba-bus";
		interrupt-parent = <&gic>;
		ranges;

		/*rtc0: rtc@FFF04000 {
				compatible = "arm,rtc-pl031", "arm,primecell";
				reg = <0xfff04000 0x1000>;
				interrupts = <0 46 0x4>;
				clocks = <&pclk>;
				clock-names = "apb_pclk";
				status = "ok";
		};*/

		/* rtc@FFF05000 {
				compatible = "arm,rtc-pl031", "arm,primecell";
				reg = <0xfff05000 0x1000>;
				interrupts = <0 47 0x4>;
				clocks = <&pclk>;
				clock-names = "apb_pclk";
				status = "ok";
		};*/


                watchdog@ffd7c000{
                        compatible = "hisilicon,iomcu-watchdog";
                        reg = <0x0 0xFFD7C000 0x0 0x1000>;
                        status = "ok";
                };

		/*wdt1@e8a07000 {
			compatible = "arm,sp805", "arm,primecell";
			reg = <0x0 0xe8a07000 0x0 0x1000>;
			interrupts = <0 45 4>;
			clocks = <&pclk_gate_wd0 &pclk>;
			clock-names = "pclk_wd0", "apb_pclk";
		};*/

		uart@fdf02000 {
			status = "ok";
		};

		uart@fdf00000 {
			status = "disabled";
		};

		uart@fdf03000 {
			status = "ok";
		};

		uart@ffd74000 {
			status = "disabled";
		};

		uart@fdf01000 {
			status = "ok";
		};

		uart@fdf05000 {
			status = "ok";
		};

		uart@fff32000 {
			status = "ok";
		};

		dx_cc63p@fdf0e000 {
			compatible = "dx,cc63p";
			reg = <0x0 0xfdf0e000 0x0 0x1000>;
			interrupt-parent = <&gic>;
			interrupts = <0 135 4>;
			status = "ok";
		};

		spi@ffd70000 {
			status = "disabled";

			spi_dev1@1 {
					compatible = "spi_dev1";
					spi-max-frequency = <13000000>;
					reg = <1>;
					pl022,com-mode = <1>;
					pl022,interface = <0>;
					pl022,rx-level-trig = <3>;
					pl022,tx-level-trig = <3>;
					pl022,ctrl-len = <7>;
					pl022,wait-state = <0>;
					pl022,duplex = <0>;
					pl022,slave-tx-disable = <0>;
			};

			spi_dev2@2 {
					compatible = "spi_dev2";
					spi-max-frequency = <13000000>;
					reg = <2>;
					pl022,com-mode = <2>;
					pl022,interface = <0>;
					pl022,rx-level-trig = <3>;
					pl022,tx-level-trig = <3>;
					pl022,ctrl-len = <7>;
					pl022,wait-state = <0>;
					pl022,duplex = <0>;
					pl022,slave-tx-disable = <0>;
			};

			spi_dev3@3 {
					compatible = "spi_dev3";
					spi-max-frequency = <13000000>;
					reg = <3>;
					pl022,com-mode = <0>;
					pl022,interface = <0>;
					pl022,rx-level-trig = <3>;
					pl022,tx-level-trig = <3>;
					pl022,ctrl-len = <7>;
					pl022,wait-state = <0>;
					pl022,duplex = <0>;
					pl022,slave-tx-disable = <0>;
			};
		};

		spi@fdf08000 {
			status = "disabled";

			spi_dev10@10 {
					compatible = "spi_dev10";
					spi-max-frequency = <100000>;
					reg = <0>;
					pl022,com-mode = <0>;
					pl022,interface = <0>;
					pl022,rx-level-trig = <3>;
					pl022,tx-level-trig = <3>;
					pl022,ctrl-len = <7>;
					pl022,wait-state = <0>;
					pl022,duplex = <0>;
					pl022,slave-tx-disable = <0>;
			};
		};

		spi@fff2a000 { /*SPI3*/
			status = "disabled";
		};
		/* I2C0 ~ I2C4 */
		i2c@FFD71000 {
			status = "disabled";
		};

		i2c@FFD72000 {
			status = "disabled";
		};

		i2c@FDF0C000 {
			status = "ok";

			fusb30x_kirin980_i2c3@22 {
				status = "ok";
				fairchild,int_n = <&gpio33 3 0>;
				pd,sink-pdo-number = <1>;
			};
			rt1711_kirin980_i2c3@4e {
				status = "ok";
				rt1711,irq_pin = <&gpio33 3 0>;
				pd-data {
					pd,sink-pdo-size = <1>;
					pd,sink-pdo-data = <0x000190c8>;
				};
                        };

			fpf2283_kirin980_i2c3@6c {
				compatible = "huawei,fpf2283_vsys";
				reg = <0x6c>;
				gpio_en = <&gpio29 1 0>;
				status = "ok";
			};
		};

		i2c@FDF0D000 {
			status = "ok";
			clock-rate = <0 111000000>;
			pinctrl-names = "default", "idle";
			pinctrl-0 = <&gpio029_pmx_func &gpio030_pmx_func &gpio029_cfg_func &gpio030_cfg_func>;
			pinctrl-1 = <&gpio029_pmx_idle &gpio030_pmx_idle &gpio029_cfg_idle &gpio030_cfg_idle>;
			cs-gpios = <&gpio3 5 0>, <&gpio3 6 0>;

			fpf2283_main_i2c4@6C {
				status = "ok";
				gpio_int = <&gpio1 1 0>;
				gpio_en = <&gpio0 7 0>;
			};

			smartpa@34{
				compatible = "huawei,smartpakit_i2c";
				reg = <0x34>;
				/* 0 MAXIM, 1 NXP, 2 TI, 3 OTHER, 4:huawei customize */
				chip_vendor = <4>;
				/* refer to smartpakit.out_device prop */
				chip_id = <1>;
				chip_model = "tfa9874";
				status = "ok";

				/* reg_ctl node: a node contains three data<addr value ctl_type>
				 * ctl_type: 0 read reg(default), 1 write reg, 2 only time delay
				 * value:
				 *     read:  reg number(num >= 1)
				 *     write: reg value
				 *     delay: time delay
				 * time delay unit: msecs */
				version_regs = <0x03 1 0>;
				dump_regs = <0 256 0>;
				hw_reset {
					gpio_reset = <245>;
					/* gpio_state node: a node contains two data<state delay>
					 * time delay unit: msecs */
					ctl_sequence = <1 1 0 1>;
				};
				irq_handler {
					gpio_irq = <201>;
					/* 0x0 IRQF_TRIGGER_NONE, 0x1 IRQF_TRIGGER_RISING, 0x2 IRQF_TRIGGER_FALLING, 0x4 IRQF_TRIGGER_HIGH, 0x8 IRQF_TRIGGER_LOW*/
					irq_flags = <2>;
					/* whether or not need reset chip*/
					need_reset;
					rw_sequence = <
						0x10 1 0
						0x11 1 0
						0x13 1 0
						0x14 1 0
						0x40 1 0
						0x41 1 0
						0x42 1 0
					>;
				};

				regmap_cfg {
					reg_bits = <8>;
					val_bits = <16>;
					/* 0 REGCACHE_NONE, 1 REGCACHE_RBTREE, 2 REGCACHE_COMPRESSED, 3 REGCACHE_FLAT */
					cache_type = <0>;
					max_register = <0xff>;
					reg_defaults = <
						0x00 0x1801
						0x01 0x0014
					>;
				};
			};
			smartpa@37{
				compatible = "huawei,smartpakit_i2c";
				reg = <0x37>;
				/* 0 MAXIM, 1 NXP, 2 TI, 3 OTHER, 4:huawei customize */
				chip_vendor = <4>;
				/* refer to smartpakit.out_device prop */
				chip_id = <0>;
				chip_model = "tfa9874";
				status = "ok";

				/* reg_ctl node: a node contains three data<addr value ctl_type>
				 * ctl_type: 0 read reg(default), 1 write reg, 2 only time delay
				 * value:
				 *     read:  reg number(num >= 1)
				 *     write: reg value
				 *     delay: time delay
				 * time delay unit: msecs */
				version_regs = <0x03 1 0>;
				dump_regs = <0 256 0>;
				hw_reset {
					gpio_reset = <257>;
					/* gpio_state node: a node contains two data<state delay>
					 * time delay unit: msecs */
					ctl_sequence = <1 1 0 1>;
				};
				irq_handler {
					gpio_irq = <241>;
					/* 0x0 IRQF_TRIGGER_NONE, 0x1 IRQF_TRIGGER_RISING, 0x2 IRQF_TRIGGER_FALLING, 0x4 IRQF_TRIGGER_HIGH, 0x8 IRQF_TRIGGER_LOW*/
					irq_flags = <2>;
					/* whether or not need reset chip*/
					need_reset;
					rw_sequence = <
						0x10 1 0
						0x11 1 0
						0x13 1 0
						0x14 1 0
						0x40 1 0
						0x41 1 0
						0x42 1 0
					>;
				};

				regmap_cfg {
					reg_bits = <8>;
					val_bits = <16>;
					/* 0 REGCACHE_NONE, 1 REGCACHE_RBTREE, 2 REGCACHE_COMPRESSED, 3 REGCACHE_FLAT */
					cache_type = <0>;
					max_register = <0xff>;
					reg_defaults = <
						0x00 0x1801
						0x01 0x0014
					>;
				};
			};
			smartpa@50{
				compatible = "huawei,smartpakit_i2c";
				reg = <0x50>;
				/* 0 MAXIM, 1 NXP, 2 TI, 3 OTHER, 4:huawei customize */
				chip_vendor = <4>;
				/* refer to smartpakit.out_device prop */
				chip_id = <1>;
				chip_model = "cs35l36";
				status = "ok";

				/* reg_ctl node: a node contains three data<addr value ctl_type>
				* ctl_type: 0 read reg(default), 1 write reg, 2 only time delay
				* value:
				*     read:  reg number(num >= 1)
				*     write: reg value
				*     delay: time delay
				* time delay unit: msecs */
				version_regs = <0x0 1 0>;
				dump_regs = <
					0x000000 1          0
					0x000008 1          0
					0x002014 0x21       0
					0x002400 1          0
					0x002c04 0xd        0
					0x003800 0x31       0
					0x004004 1          0
					0x004220 1          0
					0x004300 1          0
					0x004800 0x3d       0
					0x004C00 1          0
					0x004C20 0x15       0
					0x006000 1          0
					0x006404 0x11       0
					0x006450 1          0
					0x006800 0x9        0
					0x006C04 1          0
					0xd00000 0x4d       0
					0xe02800 1          0>;

				hw_reset {
					gpio_reset = <245>;
					/* gpio_state node: a node contains two data<state delay>
					* time delay unit: msecs */
					ctl_sequence = <1 1 0 1>;
				};

				irq_handler {
					gpio_irq = <201>;
					/* 0x0 IRQF_TRIGGER_NONE, 0x1 IRQF_TRIGGER_RISING, 0x2 IRQF_TRIGGER_FALLING, 0x4 IRQF_TRIGGER_HIGH, 0x8 IRQF_TRIGGER_LOW*/
					irq_flags = <2>;
					/* whether or not need reset chip*/
					need_reset;
					rw_sequence = <
						0xd00020 1          0
						0xd00024 1          0
						0xd00028 1          0
						0xd0002c 1          0
						0xd00000 0xffffffff 1
						0xd00004 0xffffffff 1
						0xd00008 0xffffffff 1
						0xd0000c 0xffffffff 1
					>;
				};

				regmap_cfg {
					reg_bits = <32>;
					val_bits = <32>;
					/* 0 REGCACHE_NONE, 1 REGCACHE_RBTREE, 2 REGCACHE_COMPRESSED, 3 REGCACHE_FLAT */
					cache_type = <0>;
					max_register = <0xe0ffff>;
				};
			};

			smartpa@53{
				compatible = "huawei,smartpakit_i2c";
				reg = <0x53>;
				/* 0 MAXIM, 1 NXP, 2 TI, 3 OTHER, 4:huawei customize */
				chip_vendor = <4>;
				/* refer to smartpakit.out_device prop */
				chip_id = <0>;
				chip_model = "cs35l36";
				status = "ok";

				/* reg_ctl node: a node contains three data<addr value ctl_type>
				* ctl_type: 0 read reg(default), 1 write reg, 2 only time delay
				* value:
				*     read:  reg number(num >= 1)
				*     write: reg value
				*     delay: time delay
				* time delay unit: msecs */
				version_regs = <0x0 1 0>;
				dump_regs = <
					0x000000 1          0
					0x000008 1          0
					0x002014 0x21       0
					0x002400 1          0
					0x002c04 0xd        0
					0x003800 0x31       0
					0x004004 1          0
					0x004220 1          0
					0x004300 1          0
					0x004800 0x3d       0
					0x004C00 1          0
					0x004C20 0x15       0
					0x006000 1          0
					0x006404 0x11       0
					0x006450 1          0
					0x006800 0x9        0
					0x006C04 1          0
					0xd00000 0x4d       0
					0xe02800 1          0>;

				hw_reset {
					gpio_reset = <257>;
					/* gpio_state node: a node contains two data<state delay>
					* time delay unit: msecs */
					ctl_sequence = <1 1 0 1>;
				};

				irq_handler {
					gpio_irq = <241>;
					/* 0x0 IRQF_TRIGGER_NONE, 0x1 IRQF_TRIGGER_RISING, 0x2 IRQF_TRIGGER_FALLING, 0x4 IRQF_TRIGGER_HIGH, 0x8 IRQF_TRIGGER_LOW*/
					irq_flags = <2>;
					/* whether or not need reset chip*/
					need_reset;
					rw_sequence = <
						0xd00020 1          0
						0xd00024 1          0
						0xd00028 1          0
						0xd0002c 1          0
						0xd00000 0xffffffff 1
						0xd00004 0xffffffff 1
						0xd00008 0xffffffff 1
						0xd0000c 0xffffffff 1
					>;
				};

				regmap_cfg {
					reg_bits = <32>;
					val_bits = <32>;
					/* 0 REGCACHE_NONE, 1 REGCACHE_RBTREE, 2 REGCACHE_COMPRESSED, 3 REGCACHE_FLAT */
					cache_type = <0>;
					max_register = <0xe0ffff>;
				};
			};

			smartpa@4C{
				compatible = "huawei,smartpakit_i2c";
				reg = <0x4C>;
				/* 0 MAXIM, 1 NXP, 2 TI, 3 OTHER, 4:huawei customize */
				chip_vendor = <4>;
				/* refer to smartpakit.out_device prop */
				chip_id = <1>;
				chip_model = "tas2562";
				/* maybe trigger one irq after some chip reset, ext. tas2560
				* debounce wait time unit: msecs */
				reset_debounce_wait_time = <100>;
				status = "ok";

				/* reg_ctl node: a node contains three data<addr value ctl_type>
				* ctl_type: 0 read reg(default), 1 write reg, 2 only time delay
				* value:
				*     read:  reg number(num >= 1)
				*     write: reg value
				*     delay: time delay
				* time delay unit: msecs */
				version_regs = <
					0	0	1
					125	1	0
					>;
				dump_regs = <
					0	0	1
					0	128	0
					0	50	1
					0	128	0
					0	51	1
					0	128	0
					0	52	1
					0	128	0
				>;
				hw_reset {
					gpio_reset = <245>;
					/* gpio_state node: a node contains two data<state delay>
					* time delay unit: msecs */
					ctl_sequence = <0 3 1 2>;
				};

				irq_handler {
					gpio_irq = <201>;
					/* 0x0 IRQF_TRIGGER_NONE, 0x1 IRQF_TRIGGER_RISING, 0x2 IRQF_TRIGGER_FALLING, 0x4 IRQF_TRIGGER_HIGH, 0x8 IRQF_TRIGGER_LOW*/
					irq_flags = <2>;
					/* whether or not need reset chip*/
					need_reset;
					rw_sequence = <
						0	20	2
						0	0	1
						26	1	0
						27	1	0
						31	1	0
						32	1	0
						36	1	0
						37	1	0
						2	1	0
						120	1	0
					>;
				};

				regmap_cfg {
					reg_bits = <8>;
					val_bits = <8>;
					/* 0 REGCACHE_NONE, 1 REGCACHE_RBTREE, 2 REGCACHE_COMPRESSED, 3 REGCACHE_FLAT */
					cache_type = <0>;
					max_register = <128>;
				};
			};

			smartpa@4F{
				compatible = "huawei,smartpakit_i2c";
				reg = <0x4F>;
				/* 0 MAXIM, 1 NXP, 2 TI, 3 OTHER, 4:huawei customize */
				chip_vendor = <4>;
				/* refer to smartpakit.out_device prop */
				chip_id = <0>;
				chip_model = "tas2562";
				/* maybe trigger one irq after some chip reset, ext. tas2560
				* debounce wait time unit: msecs */
				reset_debounce_wait_time = <100>;
				status = "ok";

				/* reg_ctl node: a node contains three data<addr value ctl_type>
				* ctl_type: 0 read reg(default), 1 write reg, 2 only time delay
				* value:
				*     read:  reg number(num >= 1)
				*     write: reg value
				*     delay: time delay
				* time delay unit: msecs */
				version_regs = <
					0	0	1
					125	1	0
					>;
				dump_regs = <
					0	0	1
					0	128	0
					0	50	1
					0	128	0
					0	51	1
					0	128	0
					0	52	1
					0	128	0
				>;
				hw_reset {
					gpio_reset = <257>;
					/* gpio_state node: a node contains two data<state delay>
					* time delay unit: msecs */
					ctl_sequence = <0 3 1 2>;
				};

				irq_handler {
					gpio_irq = <241>;
					/* 0x0 IRQF_TRIGGER_NONE, 0x1 IRQF_TRIGGER_RISING, 0x2 IRQF_TRIGGER_FALLING, 0x4 IRQF_TRIGGER_HIGH, 0x8 IRQF_TRIGGER_LOW*/
					irq_flags = <2>;
					/* whether or not need reset chip*/
					need_reset;
					rw_sequence = <
						0	20	2
						0	0	1
						26	1	0
						27	1	0
						31	1	0
						32	1	0
						36	1	0
						37	1	0
						2	1	0
						120	1	0
					>;
				};

				regmap_cfg {
					reg_bits = <8>;
					val_bits = <8>;
					/* 0 REGCACHE_NONE, 1 REGCACHE_RBTREE, 2 REGCACHE_COMPRESSED, 3 REGCACHE_FLAT */
					cache_type = <0>;
					max_register = <128>;
				};
			};

			nfc@28{
				status = "ok";
				reg = <0x28>;
				compatible = "hisilicon,pn547_nfc";
				nfc_on_type = "hi6421v700_pmic";
				nfc_brcm_conf_name = "libnfc-brcm.conf";
				nfc_nxp_name = "libnfc-nxp.conf";
				nfc_card_num = <0x2>;
				clk_status ="xtal";
				pn547,dload = <&gpio31 2 0>;
				pn547,irq = <&gpio27 3 0>;
				pn547,ven = <>;
				pinctrl-1 = <&gpio250_pmx_idle &gpio219_pmx_idle>;
				pinctrl-0 = <&gpio250_pmx_func &gpio219_pmx_func>;
				pinctrl-names = "default","idle";
				clock-names = "clk_out0";
				clocks = <&clk_gate_out0>;
				nfc_chip_type = "pn80t";
				nfc_single_channel = "true";
				nfc_ese_type = "p61";
				nfc_ese_num = <0x2>;
			};
			ti,lp8556{
				compatible = "huawei,hw_lp8556";
				reg = <0x2C>;
				status = "ok";
			};

			tps65132_phy: tps65132@3e {
					status = "ok";
					reg = <0x3e>;
					compatible = "huawei,hw_tps65132";
			};


                        lv52134a_phy: lv52134a@42 {
                                status = "ok";
                                reg = <0x42>;
                                compatible = "huawei,hw_lv52134a";
                        };

                        rt4801h_phy: rt4801h@73 {
                                status = "ok";
                                reg = <0x73>;
                                compatible = "huawei,hw_rt4801h";
                        };

			hw_lm3642@63{
				compatible = "huawei,lm3642";
				reg = <0x63>;
				huawei,flash-name = "lm3642";
				huawei,flash-index = <0>;
				huawei,flash-type = <0>;
				huawei,need-wakelock = <0>;
				huawei,slave-address = <0x63>;
				huawei,flash-pin = <013 999 999>;
				huawei,led-type = <0>; /* 1, dual tempature; 0, dual white */
				huawei,flash-chipid = <0x00>;
				huawei,flash_current = <7>;
				huawei,torch_current = <2>;
				status = "ok";
			};

			huawei,aw3642@7F{
				compatible = "huawei,aw3642";
				reg = <0x7F>;/*actual 0x63*/
				huawei,flash-name = "aw3642";
				huawei,flash-index = <0>;
				huawei,flash-type = <0>;
				huawei,need-wakelock = <0>;
				huawei,slave-address = <0x7F>;/*actual 0x63*/
				huawei,flash-pin = <013 999 999>;
				huawei,led-type = <0>; /* 1, dual tempature; 0, dual white */
				huawei,flash-chipid = <0x36>;
				huawei,flash_current = <31>;
				huawei,torch_current = <23>;
				status = "ok";
			};

			hw_mp3331@67{
				compatible = "huawei,mp3331";
				reg = <0x67>;
				huawei,flash-name = "mp3331";
				huawei,flash-index = <0>;
				huawei,flash-type = <0>;
				huawei,need-wakelock = <0>;
				huawei,slave-address = <0x67>;
				huawei,flash-pin = <013 999 999>;
				huawei,led-type = <0>;
				huawei,flash_current = <24>;
				huawei,torch_current = <5>;
				huawei,flash-chipid = <0x18>;
				status = "ok";
			};

			huawei,vl53l0@29{
				compatible = "huawei,vl53l0_970";
				huawei,laser_name = "vl53l0_970";
				reg = <0x29>;
				product_name = "ALPS_LASER";
				/*avdd-supply = <&ldo34>;*/
				/*#huawei,ldo-names = "avdd";*/
				gpios = <&gpio4 3 0 &gpio24 4 0>;
				huawei,gpio-ctrl-types = "xsdn", "intr";
				/*pinctrl-names = "default", "idle";
				pinctrl-0 = <&gpio035_pmx_func &gpio035_cfg_func>;
				pinctrl-1 = <&gpio035_pmx_idle &gpio035_cfg_idle>;
				*/
				status = "disabled";
			};
			fan53880@35 {
				compatible = "hisi,fan53880";
				reg = <0x35>;
				hisi,pmic_name = "fan53880";
				hisi,pmic_index = <0>;
				hisi,slave_address = <0x35>;
				hisi,pmic-pin = <75>;
				fastboot_i2c_bus = <4>;
				fastboot_support = <1>;
				status = "ok";
			};
			rt5112@20 {
				compatible = "hisi,rt5112";
				reg = <0x20>;
				hisi,pmic_name = "rt5112";
				hisi,pmic_index = <0>;
				hisi,slave_address = <0x20>;
				hisi,pmic-pin = <75>;
				fastboot_i2c_bus = <4>;
				fastboot_support = <1>;
				status = "ok";
			};
			ams_tcs3707@39 {
				status = "ok";
				reg = <0x39>;
				compatible = "ams,tcs3707";
			};
		};

		i2c@FDF0A000 {
			status = "ok";

			bq25882_charger_i2c6@6B{
				gpio_cd = <&gpio16 7 0>;
				gpio_int = <&gpio27 2 0>;
				status = "ok";
			};

			da9313_kirin980_i2c6@68 {
				compatible = "huawei,da9313";
				reg = <0x68>;
				gpio_pwron = <&gpio28 7 0>;
				gpio_irq = <&gpio29 4 0>;
				support_pwrdown_mode = <0>;
				status = "ok";
			};

			ina231_i2c6@41 {
				status = "ok";
				gpio_int = <&gpio30 2 0>;
			};
			fpf2283_aux_i2c6@6C {
				status = "ok";
			};
			fsa9685_i2c6@25 {
				compatible = "huawei,fairchild_fsa9685";
				reg = <0x25>;
				fairchild_fsa9685,gpio-intb = <&gpio23 0 0>;
				usbid-enable = <0>;
				fcp_support = <0>;
				scp_support = <1>;
				mhl_detect_disable = <1>;
				power_by_5v = <1>;
				status = "ok";
			};
		};

		i2c@FDF0B000 {
			status = "ok";
		};
	};
	/* end amba */
	/*ts kit*/
	&ts_kit {
		status = "ok";
		compatible = "huawei,ts_kit";
		bus_type = "i2c";
		product = "RLI";
		bus_id = <7>;
		has_virtualkey = <0>;
		fpga_flag = <0>;
		irq_gpio = <&gpio26 4 0>;
		reset_gpio = <&gpio1 7 0>;
		aft_enable = <1>;
		drv_stop_width = <0>;
		lcd_width = <0>;
		lcd_height = <0>;
		st_ts@49 {
			i2c_address = <0x49>;
			compatible = "st_ts";
			x_max = <2480>;
			y_max = <2200>;
			x_max_mt = <2480>;
			y_max_mt = <2200>;
			irq_config = <0>;
			algo_id = <1>;
			unite_cap_test_interface = <1>;
			vci_gpio_type = <0>;
			vci_regulator_type = <1>;
			vci_pmic_type = <0>;
			vddio_gpio_type = <0>;
			vddio_regulator_type = <1>;
			vddio_pmic_type = <0>;
			/* vci_ctrl_gpio = <&gpio6 4 0>; */
			/* vddio_ctrl_gpio = <&gpio8 3 0>; */
			st-io-supply = <&ldo29>;
			st-vci-supply = <&ldo17>;
			supported_func_indicater = <0x01>;
			self_cap_test_support = <0x01>;
			support_gesture_mode = <1>;
			fake_project_id = "P088871300";
			use_lcdkit_power_notify = <1>;
		};
	};
	&hisi_gpio_key {
		compatible = "hisilicon,gpio-key";
		pinctrl-names = "default", "idle";
		pinctrl-0 = <&gpio213_cfg_func &gpio210_cfg_func>;
		pinctrl-1 = <&gpio213_cfg_idle &gpio210_cfg_idle>;
		gpio-keyup,gpio-irq = <&gpio26 5 0>;
		gpio-keydown,gpio-irq = <&gpio26 2 0>;
		status = "ok";
	};

	/* display start */
	&framebuffer {
		fpga_flag = <0>;
		//FB_ACCEL_KIRIN980
		dss_version_tag = <0x100>;
	};

	&panel_pwm {
		#address-cells = <2>;
		#size-cells = <2>;
		compatible = "hisilicon,hisipwm";
		reg = <0 0xE8A04000 0 0x1000>;
		clocks = <&clk_gate_pwm>;
		clock-names = "clk_pwm";
		//pinctrl-names = "default","idle";
		//pinctrl-0 = <&gpio182_pmx_func &gpio182_cfg_func>;
		//pinctrl-1 = <&gpio182_pmx_idle &gpio182_cfg_idle>;
		fpga_flag = <0>;
		status = "disabled";
	};

	&panel_blpwm {
		#address-cells = <2>;
		#size-cells = <2>;
		compatible = "hisilicon,hisiblpwm";
		reg = <0 0xFFD75000 0 0x1000>;
		clocks = <&clk_gate_blpwm>;
		clock-names = "clk_blpwm";
		pinctrl-names = "default","idle";
		pinctrl-0 = <&gpio185_pmx_func &gpio186_pmx_func &gpio185_cfg_func &gpio186_cfg_func>;
		pinctrl-1 = <&gpio185_pmx_idle &gpio186_pmx_idle &gpio185_cfg_idle &gpio186_cfg_idle>;
		fpga_flag = <0>;
		status = "ok";
	};

	&panel_lcdc_fake {
		#address-cells = <2>;
		#size-cells = <2>;
		compatible = "hisilicon,lcdc_fake_panel";
		fpga_flag = <0>;
		status = "disabled";
	};

	&panel_mipi_fake {
		#address-cells = <2>;
		#size-cells = <2>;
		compatible = "hisilicon,mipi_fake_panel";
		fpga_flag = <0>;
		status = "disabled";
	};

	&huawei_lcd_panel {
		compatible = "huawei,lcd_panel_type";
		product_id = <9000>;
		detect_type = <2>; /*0:DETECT_GPIOID  1:DETECT_CHIPID  2:DETECT_LCD_TYPE */
		gpio_id = <16>; /*ID0 */
		gpio_cfg_addr = <0xE896CF24>; /*IOCG*/
		support_lcd_type = "LCD_KIT";
		lcd_panel_type = "auo_otm1901a_5p2_1080p_video";
	};

	&huawei_lcd_config {
		compatible = "simple-bus";
	};

	&panel_lcd_cmi_NT35521 {
		#address-cells = <2>;
		#size-cells = <2>;
		compatible = "hisilicon,mipi_cmi_NT35521";
		//2:PWM,  4:BLPWM,  8:MIPI
		lcd-bl-type = <8>;
		//8:PANEL_MIPI_VIDEO,  16:PANEL_MIPI_CMD
		lcd-display-type = <8>;
		//0:IFBC_TYPE_NONE
		lcd-ifbc-type = <0>;
		//gpio_lcd_vcc1v8, gpio_lcd_p5v5_enable, gpio_lcd_n5v5_enable, gpio_lcd_reset, gpio_lcd_bl_enable
		gpios = <&gpio16 2 0>, <&gpio16 0 0>,  <&gpio20 7 0>, <&gpio17 3 0>, <&gpio20 6 0>;
		gpio_nums = <130 128 167 139 166>;
		//lcdio-vcc-supply = <&ldo4>;
		//lcdanalog-vcc-supply = <&ldo17>;
		//pinctrl-names = "default", "idle";
		//pinctrl-0 = <&gpio021_pmx_func &gpio021_cfg_func &gpio009_cfg_func &gpio010_cfg_func &gpio015_cfg_func &gpio020_cfg_func>;
		//pinctrl-1 = <&gpio021_pmx_idle &gpio021_cfg_idle &gpio009_cfg_idle &gpio010_cfg_idle &gpio015_cfg_idle &gpio020_cfg_idle>;
		fpga_flag = <1>;
		status = "disabled";
	};

	&panel_lcd_jdi_R63452 {
		#address-cells = <2>;
		#size-cells = <2>;
		compatible = "hisilicon,mipi_jdi_R63452";
		//2:PWM,  4:BLPWM,  8:MIPI
		lcd-bl-type = <4>;
		//8:PANEL_MIPI_VIDEO,  16:PANEL_MIPI_CMD ,32:PANEL_DUAL_MIPI_VIDEO, 64:PANEL_DUAL_MIPI_CMD
		lcd-display-type = <16>;
		//0:IFBC_TYPE_NONE 7:IFBC_TYPE_VESA3X_SINGLE 9:IFBC_TYPE_VESA3X_DUAL
		lcd-ifbc-type = <0>;
		//vsp, vsn, lcd_reset, bl_enable, ID0,ID1,TE0
		/*vsp, vsn, rst, bl_en, id0, id1, te0*/
		//GPIO_011, GPIO_008, GPIO_189, GPIO_010, GPIO_016, GPIO_009, GPIO_003
		gpios = <&gpio1 3 0>, <&gpio1 0 0>,  <&gpio23 5 0>, <&gpio1 2 0>, <&gpio2 0 0>, <&gpio1 1 0>, <&gpio0 3 0>;
		gpio_nums = <11 8 189 10 16 9 3>;
		lcdio-vcc-supply = <&ldo4>;
		lcdanalog-vcc-supply = <&ldo17>;
		pinctrl-names = "default", "idle";

		pinctrl-0 = <&gpio011_pmx_func &gpio008_pmx_func &gpio189_pmx_func &gpio010_pmx_func &gpio011_cfg_func &gpio008_cfg_func &gpio189_cfg_func &gpio010_cfg_func &gpio016_cfg_func &gpio009_cfg_func>;
		pinctrl-1 = <&gpio011_pmx_idle &gpio008_pmx_idle &gpio189_pmx_idle &gpio010_pmx_idle &gpio011_cfg_idle &gpio008_cfg_idle &gpio189_cfg_idle &gpio010_cfg_idle &gpio016_cfg_idle &gpio009_cfg_idle>;
		fpga_flag = <0>;
		status = "disabled";
	};
	&panel_lcd_lg_TD4322 {
		compatible = "hisilicon,mipi_lg_TD4322";
		//2:PWM,  4:BLPWM,  8:MIPI
		lcd-bl-type = <4>;
		//8:PANEL_MIPI_VIDEO,  16:PANEL_MIPI_CMD ,32:PANEL_DUAL_MIPI_VIDEO, 64:PANEL_DUAL_MIPI_CMD
		lcd-display-type = <16>;
		//0:IFBC_TYPE_NONE 7:IFBC_TYPE_VESA3X_SINGLE 9:IFBC_TYPE_VESA3X_DUAL
		lcd-ifbc-type = <0>;
		//vsp, vsn, lcd_reset, bl_enable, ID0,ID1,TE0
		/*vsp, vsn, rst, bl_en, id0, id1, te0*/
		//GPIO_011, GPIO_008, GPIO_189, GPIO_010, GPIO_016, GPIO_009, GPIO_003
		gpios = <&gpio1 3 0>, <&gpio1 0 0>,  <&gpio23 5 0>, <&gpio1 2 0>, <&gpio2 0 0>, <&gpio1 1 0>, <&gpio0 3 0>;
		gpio_nums = <11 8 189 10 16 9 3>;
		lcdio-vcc-supply = <&ldo4>;
		lcdanalog-vcc-supply = <&ldo17>;
		pinctrl-names = "default", "idle";

		pinctrl-0 = <&gpio011_pmx_func &gpio008_pmx_func &gpio189_pmx_func &gpio010_pmx_func &gpio011_cfg_func &gpio008_cfg_func &gpio189_cfg_func &gpio010_cfg_func &gpio016_cfg_func &gpio009_cfg_func>;
		pinctrl-1 = <&gpio011_pmx_idle &gpio008_pmx_idle &gpio189_pmx_idle &gpio010_pmx_idle &gpio011_cfg_idle &gpio008_cfg_idle &gpio189_cfg_idle &gpio010_cfg_idle &gpio016_cfg_idle &gpio009_cfg_idle>;
		fpga_flag = <0>;
		status = "disabled";
	};
	&panel_lcd_sharp_NT36870 {
		compatible = "hisilicon,mipi_sharp_NT36870";
		//2:PWM,  4:BLPWM,  8:MIPI
		lcd-bl-type = <4>;
		//8:PANEL_MIPI_VIDEO,  16:PANEL_MIPI_CMD ,32:PANEL_DUAL_MIPI_VIDEO, 64:PANEL_DUAL_MIPI_CMD
		lcd-display-type = <16>;
		//0:IFBC_TYPE_NONE 7:IFBC_TYPE_VESA3X_SINGLE 9:IFBC_TYPE_VESA3X_DUAL
		lcd-ifbc-type = <0>;
		//vsp, vsn, lcd_reset, bl_enable, ID0,ID1,TE0
		/*vsp, vsn, rst, bl_en, id0, id1, te0*/
		//GPIO_011, GPIO_008, GPIO_189, GPIO_010, GPIO_016, GPIO_009, GPIO_003
		gpios = <&gpio1 3 0>, <&gpio1 0 0>,  <&gpio23 5 0>, <&gpio1 2 0>, <&gpio2 0 0>, <&gpio1 1 0>, <&gpio0 3 0>;
		gpio_nums = <11 8 189 10 16 9 3>;
		lcdio-vcc-supply = <&ldo4>;
		lcdanalog-vcc-supply = <&ldo17>;
		pinctrl-names = "default", "idle";

		pinctrl-0 = <&gpio011_pmx_func &gpio008_pmx_func &gpio189_pmx_func &gpio010_pmx_func &gpio011_cfg_func &gpio008_cfg_func &gpio189_cfg_func &gpio010_cfg_func &gpio016_cfg_func &gpio009_cfg_func>;
		pinctrl-1 = <&gpio011_pmx_idle &gpio008_pmx_idle &gpio189_pmx_idle &gpio010_pmx_idle &gpio011_cfg_idle &gpio008_cfg_idle &gpio189_cfg_idle &gpio010_cfg_idle &gpio016_cfg_idle &gpio009_cfg_idle>;
		fpga_flag = <0>;
		status = "disabled";
	};

	&panel_lcd_jdi_NT36860 {
		#address-cells = <2>;
		#size-cells = <2>;
		compatible = "hisilicon,mipi_jdi_NT36860";
		//2:PWM,  4:BLPWM,  8:MIPI
		lcd-bl-type = <8>;
		//8:PANEL_MIPI_VIDEO,  16:PANEL_MIPI_CMD
		lcd-display-type = <16>;
		//0:IFBC_TYPE_NONE 7:IFBC_TYPE_VESA3X_SINGLE 9:IFBC_TYPE_VESA3X_DUAL
		lcd-ifbc-type = <0>;
		//gpio_lcd_vcc1v8, gpio_lcd_p5v5_enable, gpio_lcd_n5v5_enable, gpio_lcd_reset, gpio_lcd_bl_enable, gpio_lcd_tp2v85 ,gpio_lcd_tp1v8
		gpios = <&gpio16 2 0>, <&gpio16 0 0>,  <&gpio20 7 0>, <&gpio17 3 0>, <&gpio20 6 0>, <&gpio17 1 0>, <&gpio16 1 0>;
		gpio_nums = <130 128 167 139 166 137 129>;
		//lcdio-vcc-supply = <&ldo4>;
		//lcdanalog-vcc-supply = <&ldo17>;
		//pinctrl-names = "default", "idle";
		//pinctrl-0 = <&gpio021_pmx_func &gpio021_cfg_func &gpio009_cfg_func &gpio010_cfg_func &gpio015_cfg_func &gpio020_cfg_func>;
		//pinctrl-1 = <&gpio021_pmx_idle &gpio021_cfg_idle &gpio009_cfg_idle &gpio010_cfg_idle &gpio015_cfg_idle &gpio020_cfg_idle>;
		fpga_flag = <0>;
		status = "disabled";
	};

	&panel_lcd_sharp_NT36860 {
		#address-cells = <2>;
		#size-cells = <2>;
		compatible = "hisilicon,mipi_sharp_NT36860";
		//2:PWM,  4:BLPWM,  8:MIPI
		lcd-bl-type = <8>;
		//8:PANEL_MIPI_VIDEO,  16:PANEL_MIPI_CMD
		lcd-display-type = <16>;
		//0:IFBC_TYPE_NONE 7:IFBC_TYPE_VESA3X_SINGLE 9:IFBC_TYPE_VESA3X_DUAL
		lcd-ifbc-type = <0>;
		//gpio_lcd_vcc1v8, gpio_lcd_p5v5_enable, gpio_lcd_n5v5_enable, gpio_lcd_reset, gpio_lcd_bl_enable, gpio_lcd_tp2v85 ,gpio_lcd_tp1v8
		gpios = <&gpio16 2 0>, <&gpio16 0 0>,  <&gpio20 7 0>, <&gpio17 3 0>, <&gpio20 6 0>, <&gpio17 1 0>, <&gpio16 1 0>;
		gpio_nums = <130 128 167 139 166 137 129>;
		//lcdio-vcc-supply = <&ldo4>;
		//lcdanalog-vcc-supply = <&ldo17>;
		//pinctrl-names = "default", "idle";
		//pinctrl-0 = <&gpio021_pmx_func &gpio021_cfg_func &gpio009_cfg_func &gpio010_cfg_func &gpio015_cfg_func &gpio020_cfg_func>;
		//pinctrl-1 = <&gpio021_pmx_idle &gpio021_cfg_idle &gpio009_cfg_idle &gpio010_cfg_idle &gpio015_cfg_idle &gpio020_cfg_idle>;
		fpga_flag = <0>;
		status = "disabled";
	};

	&panel_mipi_lcd_external {
		#address-cells = <2>;
		#size-cells = <2>;
		compatible = "hisilicon,mipi_lcd_external_panel";
		//2:PWM,  4:BLPWM,  8:MIPI
		lcd-bl-type = <8>;
		//8:PANEL_MIPI_VIDEO,  16:PANEL_MIPI_CMD
		lcd-display-type = <8>;
		//0:IFBC_TYPE_NONE
		lcd-ifbc-type = <0>;
		//gpio_lcd_vcc1v8, gpio_lcd_p5v5_enable, gpio_lcd_n5v5_enable, gpio_lcd_reset, gpio_lcd_bl_enable, gpio_TP_2V85_EN_B, gpio_TP_1V8_EN_B
		gpios = <&gpio16 3 0>, <&gpio17 0 0>,  <&gpio20 1 0>, <&gpio17 7 0>, <&gpio20 0 0>, <&gpio17 5 0>, <&gpio16 4 0>;
		gpio_nums = <131 136 161 143 160 141 132>;
		//lcdio-vcc-supply = <&ldo4>;
		//lcdanalog-vcc-supply = <&ldo17>;
		//pinctrl-names = "default", "idle";
		//pinctrl-0 = <&gpio021_pmx_func &gpio021_cfg_func &gpio009_cfg_func &gpio010_cfg_func &gpio015_cfg_func &gpio020_cfg_func>;
		//pinctrl-1 = <&gpio021_pmx_idle &gpio021_cfg_idle &gpio009_cfg_idle &gpio010_cfg_idle &gpio015_cfg_idle &gpio020_cfg_idle>;
		fpga_flag = <0>;
		status = "disabled";
	};
	&panel_hdmi_fake {
		#address-cells = <2>;
		#size-cells = <2>;
		compatible = "hisilicon,hdmi_fake_panel";
		fake_hdmi = <1>;
		status = "disabled";
	};
	&panel_dp_fake {
		#address-cells = <2>;
		#size-cells = <2>;
		compatible = "hisilicon,dp_fake_panel";
		fake_dp = <1>;
		status = "ok";
	};
	&hisi_dp {
		status = "ok";
	};
	&dp_aux_switch {
		compatible = "huawei,dp_aux_switch";
		aux_switch_from_fsa4476;
		aux_switch_with_uart;
		aux_uart-gpio = <&gpio26 0 0>;
		status = "ok";
	};

	/*set dp source default mode*/
	&dp_source_switch {
		compatible = "huawei,dp_source_switch";
		dp_default_source_mode = <1>; /*0:diff mode 1:same mode*/
		// for MMIE test in factory version
		check_lanes_rate;
		check_display_4k;
		need_report_event;
		status = "ok";
	};

	&huawei_usbvbus {
		compatible = "huawei,usbvbus";
		pmic_vbus_attach_enable = <0>;
		status = "ok";
	};
	/* display end */

	/* audio device beg */
	&codec_controller {
		gpios = <&gpio26 3 0>; /* GPIO_211 */
		gpio_reset = <74>; /* GPIO_74*/
		gpio_codec_ssi = <204>;
		gpio_codec_ssi_func = <1>;
		gpio_ssi_mux = <16>; /* Chicago only */
		hisilicon,codec-sel = "hi6405";
		slimbusclk_io_driver = <0x3>;
		slimbusdata_io_driver = <0x3>;
		pm_runtime_support;
		status = "ok";

		hi64xx_irq: hi64xx_irq@0 {
			status = "ok";

			hi6402_codec: hi6402_codec@0{
				hisilicon,mic_num = <2>;
				status = "disabled";
			};

			hi6403_codec: hi6403_codec@0{
				hisilicon,mic_num = <2>;
				fm_enable = <1>;
				hisilicon,wakeup_hisi_algo_support = <1>;
				status = "disabled";
			};

			hi6405_codec: hi6405_codec@0{
				hs_detect_extern_cable = <1>;
				hisilicon,wakeup_hisi_algo_support = <1>;
				hisilicon,mic_num = <3>;
				status = "ok";
			};

			pmx4: hi6402_pinctrl {
				status = "disabled";
			};
		};
	};

	&sound_hi6403 {
		compatible = "hisilicon,hi3xxx-hi6403";
		status = "disabled";
	};

	&sound_hi6405 {
		compatible = "hisilicon,hi3xxx-hi6405";
		status = "ok";
	};

	&hi6210_hifi {
		compatible = "hi6210-hifi";
		status = "ok";
	};

	&hisi_dp_machine {
		compatible = "hisilicon,hisi-dp-audio-machine";
		status = "ok";
	};

	&asp_irq {
		compatible = "hisilicon,hi3630-asp-irq";
		reg = <0x0 0xe804e000 0x0 0xa000>;
		#interrupt-cells = <0x2>;
		asp-irq-supply = <&asp>;
		interrupt-controller;
		interrupts = <0x0 0x88 0x4>;
		interrupt-names = "asp_irq";

		asp_common@0 {
			compatible = "hisilicon,hi3630-asp-common";
		};

		asp_srcup_normal@0 {
			compatible = "hisilicon,hi3630-srcup-normal";
			asp-srcup-normal-supply = <&asp>;
			interrupt-parent = <&asp_irq>;
			interrupts = <0x1 0x0>;
			interrupt-names = "asp_srcup_normal";
		};

		asp_srcup_dsp@0 {
			compatible = "hisilicon,hi3630-srcup-dsp";
		};

		asp_srcdown@0 {
			compatible = "hisilicon,hi3630-srcdown";
			interrupt-parent = <&asp_irq>;
		};

		asp_hdmi@0 {
			compatible = "hisilicon,hi3630-pcm-hdmi";
			interrupt-parent = <&asp_irq>;
			interrupts = <0x0 0x0>;
			interrupt-names = "asp_irq_hdmi";
		};
	};

	&codecssi {
		status = "ok";
	};

	&slimbusmisc {
		compatible = "candance,slimbus";
		reg = <0x0 0xe8050000 0x0 0xb00>,
			<0x0 0xe804e000 0x0 0xa000>,
			<0x0 0xfff0a000 0x0 0x1000>;
		interrupts = <0x0 0x96 0x4>;
		interrupt-names = "asp_irq_slimbus";
		slimbus-reg-supply = <&asp>;
		pinctrl-names = "default", "idle";
		pinctrl-0 = <&gpio193_pmx_func
				&gpio194_pmx_func
				&gpio193_cfg_func
				&gpio194_cfg_func>;
		pinctrl-1 = <&gpio193_pmx_idle
				&gpio194_pmx_idle
				&gpio193_cfg_idle
				&gpio194_cfg_idle>;
		slimbus-ssi-sel = "slimbus";
		asp_power_state_offset = <0x06c>;
		slimbusclk_io_driver = <0xa8>;
		slimbusdata_io_driver = <0xa3>;
		slimbusclk_offset = <0x034>;
		slimbusdata_offset = <0x038>;
		slimbusclk_cfg_offset = <0x85C>;
		slimbusdata_cfg_offset = <0x860>;
		platform-type   = "UDP";
		codec-type = "slimbus-6405";
		clk_asp_subsys = <415000>;
		slimbus_dynamic_freq= "true";
		pm_runtime_support;
		status = "ok";
	};
	&slimbus_dai {
		compatible = "hisilicon,slimbus-dai";
		status = "ok";
	};

	&sio1 {
		compatible = "hisilicon,hi3630-sio";
		reg = <0x0 0xE804F000 0x0 0x400>;
		sio-audio-supply = <&asp>;
		/* wbd
		pinctrl-names = "default", "idle";
		pinctrl-0 = <&gpio183_pmx_func
				    &gpio184_pmx_func
				    &gpio185_pmx_func
				    &gpio186_pmx_func
				    &gpio183_cfg_func
				    &gpio184_cfg_func
				    &gpio185_cfg_func
				     &gpio186_cfg_func>;
		pinctrl-1 = <&gpio183_pmx_idle
				    &gpio184_pmx_idle
				    &gpio185_pmx_idle
				    &gpio186_pmx_idle
				    &gpio183_cfg_idle
				    &gpio184_cfg_idle
				    &gpio185_cfg_idle
				    &gpio186_cfg_idle>;
		*/
		status = "disabled";
	};

	&sio2 {
		compatible = "hisilicon,hi3630-sio";
		reg = <0x0 0xE804F400 0x0 0x400>;
		sio-voice-supply = <&asp>;
		/* wbd
		pinctrl-names = "default", "idle";
		pinctrl-0 = <&gpio043_pmx_func
				     &gpio044_pmx_func
				     &gpio045_pmx_func
				     &gpio046_pmx_func
				     &gpio043_cfg_func
				     &gpio044_cfg_func
				     &gpio045_cfg_func
				     &gpio046_cfg_func>;
			pinctrl-1 = <&gpio043_pmx_idle
				     &gpio044_pmx_idle
				     &gpio045_pmx_idle
				     &gpio046_pmx_idle
				     &gpio043_cfg_idle
				     &gpio044_cfg_idle
				     &gpio045_cfg_idle
				     &gpio046_cfg_idle>;
		*/
		status = "disabled";
	};

	&sio3 {
		compatible = "hisilicon,hi3630-sio";
		reg = <0x0 0xE804F800 0x0 0x400>;
		status = "disabled";
	};

	&sio4 {
		compatible = "hisilicon,hi3630-sio";
		reg = <0x0 0xE804FC00 0x0 0x400>;
		status = "disabled";
	};

	&soundtrigger {
		compatible = "hisilicon,soundtrigger_dma_drv";
		reg = <0x0 0xe804b000 0x0 0x1000>;
		asp-dmac-supply = <&asp>;
		status = "ok";
	};

	&hi64xx_asp_dmac {
		compatible = "hisilicon,hi64xx-asp-dma";
		reg = <0x0 0xe804b000 0x0 0x1000>;
		asp-dmac-supply = <&asp>;
		interrupts = <0 216 4>;
		interrupt-names = "asp_dma_irq";
		status = "ok";
	};

	&asp_hdmi_dmac {
		compatible = "hisilicon,asp-hdmi-dma";
		reg = <0x0 0xe804e400 0x0 0x1000>;
		status = "ok";
	};

	&asp_cfg {
		compatible = "hisilicon,asp-cfg";
		reg = <0x0 0xe804e000 0x0 0xa000>;
		asp-supply = <&asp>;
		status = "ok";
	};

	&dp_i2s {
		compatible = "hisilicon,hisi-dp-i2s";
		status = "ok";
        };

	&dp_audio {
		compatible = "hisilicon,dp-audio";
		status = "ok";
        };

	&hisi_pcm_dp {
		compatible = "hisilicon,hisi-pcm-dp";
		interrupts = <0x0 0x96 0x4>;
		interrupt-names = "asp_hdmi_dma";
		dp-pcm-supply = <&asp>;
		status = "ok";
	};

	&hifidsp {
			compatible = "hisilicon,k3hifidsp";
			status = "ok";
			platform-type = "ASIC";
	};

	&sochifi_watchdog {
		compatible = "hisilicon,sochifi-watchdog";
		interrupts = <0 213 4>;
		status = "ok";
	};

	&asp_dmac {
		compatible = "hisilicon,hi3xxx-pcm-asp-dma";
		reg = <0x0 0xe804b000 0x0 0x1000>;
		asp-dmac-supply = <&asp>;
		status = "ok";
	};

	&usbaudio_dsp {
		compatible = "hisilicon,usbaudiodsp";
		status = "ok";
	};
	&deviceboxID {
		check_mode = "gpio";
		box_num = <1>;
		enable_boxID = <1 0 0 0>;
		gpio_num = <1 0 0 0>;
		gpio_speakerID = <&gpio30 2 0>;
		speaker_map = <1 2>;/*1 means AAC, 2 means GEER*/
		pinctrl-names = "default", "idle";
		pinctrl-0 = <&gpio242_pmx_func &gpio242_cfg_func>;
		pinctrl-1 = <&gpio242_pmx_idle &gpio242_cfg_idle>;
		deviceboxID_limit = <500>;
		status = "ok";
	};

	&smartpakit {
		compatible = "huawei,smartpakit";
		/* 0 hisi, 1 qcom */
		soc_platform = <0>;
		/* algo running on: 0 codec_dsp, 1 soc_dsp, 2 smartpa_dsp, 3 simple pa(not smpartpa), 4 simple pa(with i2c) */
		algo_in = <0>;
		/* algo_in params need match out_device for smartpa.
		 * Now, up to only support four pa, so out_device = <0 0 0 0>;
		 * 1. This array is arranged in the following order:
		 *    <0 1 2 3>
		 *    <pril prir secl secr>
		 * 2. This array element value is 0 or 1:
		 *    smartpa: 0 speaker, 1 receiver
		 *    simple pa: out_device not applicable, only set 0 to indicate pa_num
		 * 3. The length of this array is variable, for example:
		 *    single pa: out_device = <0>;
		 *    two pa: out_device = <0 0>;
		 *    four pa: out_device = <1 1 0 0>; */
		out_device = <0 1>;
		dsp_img_name = "hifi_6405_imedia150_devkit.img";
		status = "ok";
	};

	&anc_hs_default {
		compatible = "huawei,anc_hs_default";
		status = "ok";
	};


	&usb_analog_hs_interface {
		compatible = "huawei,usb_analog_hs_interface";
		status = "ok";
	};

	&usb_ana_hs_fsa4476 {
		compatible = "huawei,usb_ana_hs_fsa4476";
		gpio_type = <0>;
		swtich_enn = <&gpio4 0 0>;
		swtich_en1 = <&gpio1 3 0>;
		swtich_en2 = <&gpio17 1 0>;
		mic_switch_delay = <150>;
		pd_unlock_enable = <1>; /* 0: disable; 1: enable */
		sd_gpio_used = <1>;
		support_cc = <1>;
		status = "ok";
	};

	&audio_hw_config {
		product_name = "TAHITI";
		multi_mic_enable = "true";
		vqm_enable = "true";
		spk_pa_name = "smartpakit";
		cust_name = "audio_custom";
		soc_name = "hi363x";
		codec_name = "hi6405";
		codec_dsp_algo = "mad";
		modem_sio_master = "false";
		asr_enable = "true";
		ear_pa_name = "smartpakit";
		analog_earpiece_enable = "true";
		pa_alg_bypass = "false";
		status = "ok";
		audio_sar_support = "true";
		record_algo_version = "record5_0";
		hifi_info {
			dsp_voice_vol_control = "1";/* 1 :need socdsp control volume; 0:platform codec */
		};

		hardware_info {
			mic_num = "3";
			mic_type = "000b";/*0001 deputy mic   0002 main mic   0004 deputy mic2   0008 main mic2*/
			status = "ok";
		};

		audio_capability {
			bwe_ui_support = "true";
			bwe_support = "true";
			swb_support = "true";
			wnr_support = "false";
			nv_evs_support = "true";
			lvm_support = "false";
			dhf_support = "true";
			voice_anc_support = "false";
			dual_smartpa_support = "true";
			stereo_handfree_support = "true";
			spk_rcv_stereo_support = "true";
			dual_smartpa_version = "2.0";
			earphone_multi_eq_support = "true";
			vdr_ui_support = "false";
			asr_vibrate_support = "true";
			mmi_capture_enable = "false";
			irda_support = "true";
			visualizer_support = "true";
			visualizer_frame = "Medium";
			/*
				sound trigger feature.
				false: this product doesn't support soundtrigger feature.
				2.0: this product supports the twice wakeup feature.
			*/
			soundtrigger_version = "2.0";
			soundtrigger_enhance_enable = "true";
			soundtrigger_mic_info = "3";
			/*
				max stream volume to replace Android default volume.
			*/
			max_stream_volume = "15";
			/*
				usb compatibility report feature.
				true: this product needs usb compatibility report.
				false: this product doesn't need usb compatibility report.
			*/
			usb_compatibility_report = "true";
			music_region_enable = "false";
			voice_region_enable = "true";
			/*
				use hisilicon wakeup engine.
				true: use hisilicon wakeup engine.
				false: DO NOT use hisilicon wakeup engine.
			*/
			wakeup_hisiengine = "true";
		};
	};

	&hw_soundtrigger_event {
		status = "ok";
	};

	/* audio device end */

	/* UFS */
	&ufs {
		status = "ok";
	};

	/* rename eMMC,SD,SDIO */
	&aliases {
	};

	/* eMMC 4.5
	&dwmmc0 {
		status = "ok";
	};
	*/

	/* SD */
	/*
	while set mux-sdsim as 1,driver_strength for clk,cmd,data must be specified in dts,check config table below to make sure right value

	2MA_0   0x00
	4MA_0   0x10
	6MA_0   0x20
	8MA_0   0x30
	10MA_0  0x40
	12MA_0  0x50
	14MA_0  0x60
	16MA_0  0x70
	5MA_1   0x00
	7MA_1   0x10
	9MA_1   0x20
	11MA_1  0x30
	14MA_1  0x40
	16MA_1  0x50
	18MA_1  0x60
	20MA_1  0x70
	22MA_1  0x80
	25MA_1  0x90
	27MA_1  0xA0
	29MA_1  0xB0
	32MA_1  0xC0
	34MA_1  0xD0
	36MA_1  0xE0
	38MA_1  0xF0
	*/
	&dwmmc1 {
		caps2-mmc-hs200-1_8v;
		caps2-mmc-cache-ctrl;
		vmmc-supply = <&ldo16>;
		vqmmc-supply = <&ldo9>;
		/*define these below two config if ldo12 as switch*/
		vmmcmosen_switch = <0x01>;
		vmmcmosen-supply = <&ldo12>;
		/*define these above two config if ldo12 as switch*/
		cs_sd_timing_config_cancer;
		use_samdly_range = <5 8>;
		mux-sdsim = <1>;
		/*25MA_1 for sd clk*/
		driverstrength_clk = <0x90>;
		/*25MA_1 for sd cmd*/
		driverstrength_cmd = <0x90>;
		/*11MA_1 for sd data*/
		driverstrength_data = <0x30>;
		enable_shift_range = <4 8>;
		cd-vol = <1>;
		cd-gpio = <&gpio22 7 0>;
		shared-irq = <1>;
		status = "ok";
	};

	/* sdio */

	&dwmmc2 {
		status = "ok";
	};

	&pddevice {
		update_combophy_firmware = <1>;
	};

	&hisi_usb {
		usb_support_check_voltage = <0x0>;
		eye_diagram_host_param = <0x37DE7E7>;
		host-maximum-speed = "super-speed-plus";
		usb_support_dp = <1>;
		quirk_enable_hst_imm_retry;
		quirk_disable_rx_thres_cfg;
		quirk_disable_usb2phy_suspend;
		quirk_clear_svc_opp_per_hs;
		quirk_set_svc_opp_per_hs_sep;
		quirk_adjust_dtout;
		quirk_force_disable_host_lpm;
		quirk_enable_p4_gate;
		usb_firmware_es = <0>;
	};


	&sensorhub_status{
	};

	&sensorhub_nmi{
	};

	&sensorhub{
		#address-cells=<1>;
		#size-cells=<0>;
		als_sensor:light{
			als1{
				compatible="huawei,ams_tcs3701";
				bus_number = <0x0>;
				reg=<0x39>;
				chip_id_register = <0x92>;
				chip_id_value = <0x18>;
				file_id = <117>;
				sensor_list_info_id = <0x03>;
				sensor_type = "als";
				poll_interval = <350>;
				threshold_value = <0x1>;
				GA1 = <0x1046>;
				GA2 = <0xf3c>;
				GA3 = <0x1194>;
				tp_color = <0x0>;
				again = <0x1>;
				gpio_int1=<&gpio24 4 0>;
				gpio_int1_sh=<1003>;
				atime = <0xdb>;
				init_time = <0x96>;
				status = "ok";
				als_phone_type = <50>;
				als_phone_version = <10>;
				als_extend_data = <0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0>;
				sensorlist_name="als-tcs3701";
				vendor="ams";
			};
		};
		proximity{
			ps1 {
				compatible="huawei,ams_tcs3701";
				bus_number=<0>;
				reg=<0x39>;
				chip_id_register=<0x92>;
				chip_id_value=<0x18>;
				file_id=<118>;
				sensor_list_info_id = <0x04>;
				sensor_type="ps";
				min_proximity_value=<500>;
				pwindows_value=<60>;
				pwave_value=<50>;
				threshold_value=<65>;
				ps_calib_20cm_threshold=<240>;
				ps_calib_5cm_threshold=<400>;
				ps_calib_3cm_threshold=<500>;
				gpio_int1=<&gpio24 4 0>;
				poll_interval = <80>;
				ps_oily_threshold = <3>;
				oily_max_near_pdata=<1000>;
				max_oily_add_pdata=<100>;
				max_near_pdata_loop=<3>;
				oily_count_size=<8>;
				status = "ok";
				sensorlist_name="proximity-tcs3701";
				vendor="ams";
				fifoReservedEventCount=<100>;
				fifoMaxEventCount=<100>;
				maxDelay=<200000>;
				ptime =<70>;  //ms
				wtime =<3>; //ms
				pulse_len =<4>; //us
				ps_pulse_count =<32>;
				pgain =<1>;
				led_current=<30>;//mA
				prox_avg=<3>;
				offset_max=<200>;
				offset_min=<0>;
			};
		};
		gsensor{
			acc1{
				compatible ="huawei,st-lsm6dsm";
				bus_number =<1>;
				reg =<0x6a>;
				chip_id_register =<0x0f>;
				chip_id_value =<0x6a>;
				file_id =<34>;
				sensor_list_info_id =<0>;
				sensor_type ="acc";
				axis_map_x =<0>;
				axis_map_y =<1>;
				axis_map_z =<2>;
				negate_x =<1>;
				negate_y =<1>;
				negate_z =<0>;
				offset_x =<0>;
				offset_y =<0>;
				offset_z =<0>;
				sensitivity_x =<1>;
				sensitivity_y =<1>;
				sensitivity_z =<1>;
				poll_interval =<10>;
				gpio_int1 =<&gpio26 0 0>;
				gpio_int2=<&gpio25 7 0>;
				gpio_int2_sh=<1013>;
				used_int_pin =<1>;
				calibrate_style =<0>;
				x_calibrate_thredhold = <250>;
				y_calibrate_thredhold = <250>;
				z_calibrate_thredhold = <320>;
				sensorlist_name="accelerometer-lsm6dsm";
				vendor="st";
				maxRange=<8>;
				power=<230>;
				minDelay=<2000>;
				fifoReservedEventCount=<0>;
				fifoMaxEventCount=<0>;
				maxDelay=<200000>;
				calibrate_way=<1>;
				status = "ok";
				sensor_in_board_status = "15";// 15=0x00001111:bit0:acc1,bit1:gyro1,bit2:mag1,bit3:sar1
			};
			acc2{
				compatible ="huawei,invensense-icm20690";
				bus_number =<1>;
				reg =<0x68>;
				chip_id_register =<0x75>;
				chip_id_value =<0x20>;
				file_id =<53>;
				sensor_list_info_id =<0>;
				sensor_type ="acc";
				axis_map_x =<0>;
				axis_map_y =<1>;
				axis_map_z =<2>;
				negate_x =<1>;
				negate_y =<1>;
				negate_z =<0>;
				offset_x =<0>;
				offset_y =<0>;
				offset_z =<0>;
				sensitivity_x =<1>;
				sensitivity_y =<1>;
				sensitivity_z =<1>;
				poll_interval =<10>;
				gpio_int1 =<&gpio26 0 0>;
				gpio_int2=<&gpio25 7 0>;
				gpio_int2_sh=<1013>;
				calibrate_style =<0>;
				used_int_pin =<1>;
				x_calibrate_thredhold = <250>;
				y_calibrate_thredhold = <250>;
				z_calibrate_thredhold = <320>;
				sensorlist_name="accelerometer-icm20690";
				vendor="invensense";
				maxRange=<8>;
				power=<230>;
				minDelay=<2000>;
				fifoReservedEventCount=<0>;
				fifoMaxEventCount=<0>;
				maxDelay=<200000>;
				calibrate_way=<1>;
				status = "ok";
				sensor_in_board_status = "15";// 15=0x00001111:bit0:acc1,bit1:gyro1,bit2:mag1,bit3:sar1
			};
			acc3{
				compatible ="huawei,bosch-bmi260";
				bus_number =<1>;
				reg =<0x68>;
				chip_id_register =<0x00>;
				chip_id_value =<0x27>;
				file_id =<121>;
				sensor_list_info_id =<0>;
				sensor_type ="acc";
				axis_map_x =<1>;
				axis_map_y =<0>;
				axis_map_z =<2>;
				negate_x =<0>;
				negate_y =<1>;
				negate_z =<0>;
				offset_x =<0>;
				offset_y =<0>;
				offset_z =<0>;
				sensitivity_x =<1>;
				sensitivity_y =<1>;
				sensitivity_z =<1>;
				poll_interval =<10>;
				gpio_int1 =<&gpio26 0 0>;
				gpio_int2=<&gpio25 7 0>;
				gpio_int2_sh=<1013>;
				calibrate_style =<0>;
				used_int_pin =<1>;
				x_calibrate_thredhold = <250>;
				y_calibrate_thredhold = <250>;
				z_calibrate_thredhold = <320>;
				sensorlist_name="accelerometer-bmi260";
				vendor="bosch";
				maxRange=<8>;
				power=<230>;
				minDelay=<2000>;
				fifoReservedEventCount=<0>;
				fifoMaxEventCount=<0>;
				maxDelay=<200000>;
				calibrate_way=<1>;
				status = "ok";
				sensor_in_board_status = "15";// 15=0x00001111:bit0:acc1,bit1:gyro1,bit2:mag1,bit3:sar1
			};
			acc4{
				compatible ="huawei,st-lsm6dsm";
				bus_number =<0>;
				reg =<0x6b>;
				chip_id_register =<0x0f>;
				chip_id_value =<0x6a>;
				file_id =<34>;
				sensor_list_info_id =<31>;
				sensor_type ="acc1";
				axis_map_x =<0>;
				axis_map_y =<1>;
				axis_map_z =<2>;
				negate_x =<0>;
				negate_y =<1>;
				negate_z =<1>;
				offset_x =<0>;
				offset_y =<0>;
				offset_z =<0>;
				sensitivity_x =<1>;
				sensitivity_y =<1>;
				sensitivity_z =<1>;
				poll_interval =<10>;
				gpio_int1 =<&gpio26 0 0>;
				gpio_int2=<&gpio23 1 0>;
				gpio_int2_sh=<1013>;
				used_int_pin =<1>;
				calibrate_style =<0>;
				x_calibrate_thredhold = <250>;
				y_calibrate_thredhold = <250>;
				z_calibrate_thredhold = <320>;
				sensorlist_name="accelerometer-lsm6dsm-aux";
				vendor="st";
				maxRange=<8>;
				power=<230>;
				minDelay=<2000>;
				fifoReservedEventCount=<0>;
				fifoMaxEventCount=<0>;
				maxDelay=<200000>;
				calibrate_way=<1>;
				status = "ok";
				aux_prop = <1>;
			};
			acc5{
				compatible ="huawei,invensense-icm20690";
				bus_number =<0>;
				reg =<0x69>;
				chip_id_register =<0x75>;
				chip_id_value =<0x20>;
				file_id =<53>;
				sensor_list_info_id =<31>;
				sensor_type ="acc1";
				axis_map_x =<0>;
				axis_map_y =<1>;
				axis_map_z =<2>;
				negate_x =<0>;
				negate_y =<1>;
				negate_z =<1>;
				offset_x =<0>;
				offset_y =<0>;
				offset_z =<0>;
				sensitivity_x =<1>;
				sensitivity_y =<1>;
				sensitivity_z =<1>;
				poll_interval =<10>;
				gpio_int1 =<&gpio26 0 0>;
				gpio_int2=<&gpio23 1 0>;
				gpio_int2_sh=<1013>;
				calibrate_style =<0>;
				used_int_pin =<1>;
				x_calibrate_thredhold = <250>;
				y_calibrate_thredhold = <250>;
				z_calibrate_thredhold = <320>;
				sensorlist_name="accelerometer-icm20690-aux";
				vendor="invensense";
				maxRange=<8>;
				power=<230>;
				minDelay=<2000>;
				fifoReservedEventCount=<0>;
				fifoMaxEventCount=<0>;
				maxDelay=<200000>;
				calibrate_way=<1>;
				status = "ok";
				aux_prop = <1>;
			};
			acc6{
				compatible ="huawei,bosch-bmi260";
				bus_number =<0>;
				reg =<0x69>;
				chip_id_register =<0x00>;
				chip_id_value =<0x27>;
				file_id =<121>;
				sensor_list_info_id =<31>;
				sensor_type ="acc1";
				axis_map_x =<1>;
				axis_map_y =<0>;
				axis_map_z =<2>;
				negate_x =<1>;
				negate_y =<1>;
				negate_z =<1>;
				offset_x =<0>;
				offset_y =<0>;
				offset_z =<0>;
				sensitivity_x =<1>;
				sensitivity_y =<1>;
				sensitivity_z =<1>;
				poll_interval =<10>;
				gpio_int1 =<&gpio26 0 0>;
				gpio_int2=<&gpio23 1 0>;
				gpio_int2_sh=<1013>;
				calibrate_style =<0>;
				used_int_pin =<1>;
				x_calibrate_thredhold = <250>;
				y_calibrate_thredhold = <250>;
				z_calibrate_thredhold = <320>;
				sensorlist_name="accelerometer-bmi260-aux";
				vendor="bosch";
				maxRange=<8>;
				power=<230>;
				minDelay=<2000>;
				fifoReservedEventCount=<0>;
				fifoMaxEventCount=<0>;
				maxDelay=<200000>;
				calibrate_way=<1>;
				status = "ok";
				aux_prop = <1>;
			};
		};

		gyroscope{
			gyro1{
				compatible ="huawei,st-lsm6dsm";
				bus_number =<1>;
				reg =<0x6a>;
				chip_id_register =<0x0f>;
				chip_id_value =<0x6a>;
				file_id =<36>;
				sensor_list_info_id =<5>;
				sensor_type ="gyro";
				position = <1>;
				axis_map_x =<0>;
				axis_map_y =<1>;
				axis_map_z =<2>;
				negate_x =<1>;
				negate_y =<1>;
				negate_z =<0>;
				poll_interval =<10>;
				gpio_int1 =<&gpio26 2 0>;
				gpio_int2=<&gpio25 7 0>;
				gpio_int2_sh=<1013>;
				calibrate_thredhold = <572>;
				sensorlist_name="gyroscope-lsm6dsm";
				vendor="st";
				minDelay=<2000>;
				maxDelay=<200000>;
				calibrate_way=<1>;
				status = "ok";
			};
			gyro2{
				compatible ="huawei,inv-icm20690";
				bus_number =<1>;
				reg =<0x68>;
				chip_id_register =<0x75>;
				chip_id_value =<0x20>;
				file_id =<54>;
				sensor_list_info_id =<5>;
				sensor_type ="gyro";
				position = <1>;
				axis_map_x =<0>;
				axis_map_y =<1>;
				axis_map_z =<2>;
				negate_x =<1>;
				negate_y =<1>;
				negate_z =<0>;
				poll_interval =<10>;
				gpio_int1 =<&gpio26 2 0>;
				gpio_int2=<&gpio25 7 0>;
				gpio_int2_sh=<1013>;
				sensorlist_name="gyroscope-icm20690";
				vendor="invensense";
				minDelay=<2000>;
				maxDelay=<200000>;
				calibrate_way=<1>;
				status = "ok";
			};
			gyro3{
				compatible ="huawei,bosch-bmi260";
				bus_number =<1>;
				reg =<0x68>;
				chip_id_register =<0x00>;
				chip_id_value =<0x27>;
				file_id =<122>;
				sensor_list_info_id =<5>;
				sensor_type ="gyro";
				position = <1>;
				axis_map_x =<1>;
				axis_map_y =<0>;
				axis_map_z =<2>;
				negate_x =<0>;
				negate_y =<1>;
				negate_z =<0>;
				poll_interval =<10>;
				gpio_int1 =<&gpio26 2 0>;
				gpio_int2=<&gpio25 7 0>;
				gpio_int2_sh=<1013>;
				sensorlist_name="gyroscope-bmi260";
				vendor="bosch";
				minDelay=<2000>;
				maxDelay=<200000>;
				calibrate_way=<1>;
				status = "ok";
			};
			gyro4{
				compatible ="huawei,st-lsm6dsm";
				bus_number =<0>;
				reg =<0x6b>;
				chip_id_register =<0x0f>;
				chip_id_value =<0x6a>;
				file_id =<36>;
				sensor_list_info_id =<32>;
				sensor_type ="gyro1";
				position = <1>;
				axis_map_x =<0>;
				axis_map_y =<1>;
				axis_map_z =<2>;
				negate_x =<0>;
				negate_y =<1>;
				negate_z =<1>;
				poll_interval =<10>;
				gpio_int1 =<&gpio26 2 0>;
				gpio_int2=<&gpio23 1 0>;
				gpio_int2_sh=<1013>;
				calibrate_thredhold = <572>;
				sensorlist_name="gyroscope-lsm6dsm-aux";
				vendor="st";
				minDelay=<2000>;
				maxDelay=<200000>;
				calibrate_way=<1>;
				status = "ok";
				aux_prop = <1>;
			};
			gyro5{
				compatible ="huawei,inv-icm20690";
				bus_number =<0>;
				reg =<0x69>;
				chip_id_register =<0x75>;
				chip_id_value =<0x20>;
				file_id =<54>;
				sensor_list_info_id =<32>;
				sensor_type ="gyro1";
				position = <1>;
				axis_map_x =<0>;
				axis_map_y =<1>;
				axis_map_z =<2>;
				negate_x =<0>;
				negate_y =<1>;
				negate_z =<1>;
				poll_interval =<10>;
				gpio_int1 =<&gpio26 2 0>;
				gpio_int2=<&gpio23 1 0>;
				gpio_int2_sh=<1013>;
				sensorlist_name="gyroscope-icm20690-aux";
				vendor="invensense";
				minDelay=<2000>;
				maxDelay=<200000>;
				calibrate_way=<1>;
				status = "ok";
				aux_prop = <1>;
			};
			gyro6{
				compatible ="huawei,bosch-bmi260";
				bus_number =<0>;
				reg =<0x69>;
				chip_id_register =<0x00>;
				chip_id_value =<0x20>;
				file_id =<122>;
				sensor_list_info_id =<32>;
				sensor_type ="gyro1";
				position = <1>;
				axis_map_x =<1>;
				axis_map_y =<0>;
				axis_map_z =<2>;
				negate_x =<1>;
				negate_y =<1>;
				negate_z =<1>;
				poll_interval =<10>;
				gpio_int1 =<&gpio26 2 0>;
				gpio_int2=<&gpio23 1 0>;
				gpio_int2_sh=<1013>;
				sensorlist_name="gyroscope-bmi260-aux";
				vendor="bosch";
				minDelay=<2000>;
				maxDelay=<200000>;
				calibrate_way=<1>;
				status = "ok";
				aux_prop = <1>;
			};
		};
		compass{
			mag1 {
				compatible="huawei,akm-akm09918";
				bus_number=<0>;
				reg=<0x0C>;
				chip_id_register=<0x00>;
				chip_id_value=<0x48>;
				file_id=<67>;
				sensor_list_info_id=<37>;
				sensor_type="mag1";
				/*sensor-vdd-supply = <&ldo24>;*/
				outbit=<0>;
				calibrate_method=<2>;
				axis_map_x=<0>;
				axis_map_y=<1>;
				axis_map_z=<2>;
				negate_x=<0>;
				negate_y=<0>;
				negate_z=<0>;
				poll_interval=<10>;
				gpio_int1=<&gpio0 0 0>;
				gpio_reset=<&gpio0 0 0>;
				softiron_parameter = <16 39 0 0 0 0 0 0 16 39 0 0 0 0 0 0 16 39 0 0 0 0 0 0 0 0 0>;
				sensorlist_name="akm-akm09918-aux";
				vendor="akm";
				minDelay=<10000>;
				fifoReservedEventCount=<0>;
				fifoMaxEventCount=<0>;
				status = "ok";
				aux_prop = <1>;
			};
			mag2 {
				compatible="huawei,yamaha-yas537";
				bus_number=<0>;
				reg=<0x2E>;
				chip_id_register=<0x80>;
				chip_id_value=<0x07>;
				file_id=<66>;
				sensor_list_info_id=<1>;
				sensor_type="mag";
				/*sensor-vdd-supply = <&ldo24>;*/
				outbit=<0>;
				softfilter = <2>;
				calibrate_method=<2>;
				axis_map_x=<1>;
				axis_map_y=<0>;
				axis_map_z=<2>;
				negate_x=<1>;
				negate_y=<1>;
				negate_z=<1>;
				poll_interval=<10>;
				gpio_int1=<&gpio0 0 0>;
				gpio_reset=<&gpio0 0 0>;
				softiron_parameter = <16 39 0 0 0 0 0 0 16 39 0 0 0 0 0 0 16 39 0 0 0 0 0 0 0 0 0>;
				sensorlist_name="mag-yas537";
				vendor="yamaha";
				minDelay=<10000>;
				fifoReservedEventCount=<0>;
				fifoMaxEventCount=<0>;
				status = "ok";
			};
			mag3{
				compatible="huawei,akm-akm09911";
				bus_number=<0>;
				reg=<0x0D>;
				chip_id_register=<0x00>;
				chip_id_value=<0x48>;
				file_id=<37>;
				sensor_list_info_id=<1>;
				sensor_type="mag";
				/*sensor-vdd-supply = <&ldo24>;*/
				outbit=<0>;
				softfilter = <2>;
				calibrate_method=<2>;
				axis_map_x=<1>;
				axis_map_y=<0>;
				axis_map_z=<2>;
				negate_x=<1>;
				negate_y=<1>;
				negate_z=<1>;
				poll_interval=<10>;
				gpio_int1=<&gpio0 0 0>;
				gpio_reset=<&gpio0 0 0>;
				softiron_parameter = <16 39 0 0 0 0 0 0 16 39 0 0 0 0 0 0 16 39 0 0 0 0 0 0 0 0 0>;
				sensorlist_name="mag-akm09911";
				vendor="akm";
				minDelay=<10000>;
				fifoReservedEventCount=<0>;
				fifoMaxEventCount=<0>;
				status = "ok";
			};
		};
		airpress{
			airpress1{
				compatible="huawei,st_lps22bh";
				bus_number=<0>;
				reg=<0x5d>;
				chip_id_register=<0x0F>;
				chip_id_value=<0xB1>;
				file_id=<48>;
				sensor_list_info_id=<0x9>;
				sensor_type="airpress";
				poll_interval = <500>;
				sensorlist_name="airpress-lps22bh";
				vendor="st";
				fifoReservedEventCount=<300>;
				fifoMaxEventCount=<300>;
				status = "ok";
			};
			airpress2 {
				compatible="huawei,bosch_bmp380";
				bus_number=<0>;
				reg=<0x77>;
				chip_id_register=<0x0>;
				chip_id_value=<0x50>;
				file_id=<82>;
				sensor_list_info_id=<0x9>;
				sensor_type="airpress";
				poll_interval = <500>;
				sensorlist_name="airpress-bmp380";
				vendor="bosch";
				fifoReservedEventCount=<300>;
				fifoMaxEventCount=<300>;
				status = "ok";
			};
		};

		sar {
			sar1 {
				compatible="huawei,semtech-sx9323";
				bus_number=<0>;
				reg=<0x28>;
				chip_id_register=<0xFA>;
				chip_id_value=<0x23 0x20>;
				file_id=<62>;
				sensor_type="cap_prox";
				sensor_list_info_id=<20>;
				poll_interval=<200>;
				calibrate_type=<6>;	//bit config 101(b) adapt to the param calibrate calibrate order
				calibrate_order = "999 2 1 45";// 0:free  1:near  2:far  3:other; 45 is acc thredhold
				shared_flag=<0>;
				status = "disabled";
				phone_type = /bits/ 16 <0x06>;// 1:ALPS  2:BLANC  3:EMILY  4:NEO  5:CHARLOTTE 6:after EVER
				to_ap_threshold = /bits/ 16 <0xc8>;
				to_modem_threshold = /bits/ 16 <0x74CC 0x1770 0x7D0 0x00 0x00 0x00 0x00 0x00>;
				init_reg_val = <0x00000015 0x23012447 0x281F2A37 0x2B102C12 0x2D0B3023 0x340B3500 0x36213721 0x1016421b 0x4300443a 0x293D2601 0x27472080 0x0000311b>;
				ph = <0x2f>;
				calibrate_thred = /bits/ 16 <0 0 0 0>;//for the factory far and near calibrate
				sensorlist_name="CAP_PROX sensor-sx9323";
				vendor="semtech";
			};
			sar2 {
				compatible="huawei,semtech-sx9335";
				bus_number=<0>;
				reg=<0x2B>;
				chip_id_register=<0xD842>;
				chip_id_value=<0x16350000>;
				file_id=<124>;
				sensor_type="cap_prox1";
				sensor_list_info_id=<39>;
				aux_prop = <1> ;
				poll_interval=<200>;
				calibrate_type=<6>;	//bit config 101(b) adapt to the param calibrate calibrate order
				calibrate_order = "999 2 1 45";// 0:free  1:near  2:far  3:other;45 is acc thredhold
				shared_flag=<0>;
				status = "ok";
				phone_type = /bits/ 16 <0x06>;// 1:ALPS  2:BLANC  3:EMILY  4:NEO  5:CHARLOTTE 6:after EVER
				to_ap_threshold = /bits/ 16 <0xc8>;
				to_modem_threshold = /bits/ 16 <0x74CC 0x1770 0x7D0 0x00 0x00 0x00 0x00 0x00>;
				init_reg_val = <0x00000014 0x23012447 0x281F2A37 0x2B102C12 0x2D0B3023 0x340B3500 0x36213708 0x10164219 0x43304430 0x293D2600 0x27472080 0x00000000>;
				ph = <0x2f>;
				calibrate_thred = /bits/ 16 <0 0 0 0>;//for the factory far and near calibrate
				sensorlist_name="CAP_PROX sensor-sx9335";
				vendor="semtech";
			};
		};


		fingerprint {
			finger1 {
				compatible="goodix,goodix3206";
				combo_bus_type = "spi";
				combo_bus_num = <2>;
				combo_data = <217>;
				combo_tx = /bits/ 8 <0xF1>;
				combo_rx_mask = /bits/ 8 <0xFF 0x00 0xFF 0xFF>;
				combo_rx_exp = /bits/ 8 <0x08 0x00 0x00 0x22>;

				bus_type=<1>;
				bus_number=<2>;
				reg=<0x0>;
				chip_id_register=<0xFC>;
				chip_id_value=<0x3206>;
				product_id_value=<59>;
				file_id=<123>;
				sensor_list_info_id = <0x12>;
				sensor_type ="fingerprint";
				poll_interval = <500>;
				gpio_irq = <237>;
				gpio_irq_sh = <1029>;
				gpio_reset = <238>;
				gpio_cs = <217>;
				status = "ok";
			};
		};
		connectivity_sensor:connectivity{
			connectivity1{
				compatible="huawei,connectivity-vs";
				bus_type = <145>;
				bus_number = <1>;
				i2c_address = <0x6e>;
				reg=<0x6e>;
				chip_id_register=<0x91>;
				chip_id_value=<0x00>;
				file_id=<47>;
				sensor_type="connectivity";
				gpio1_gps_cmd_ap = <227>;
				gpio1_gps_cmd_sh = <1027>;
				gpio2_gps_ready_ap = <225>;
				gpio2_gps_ready_sh = <1025>;
				gpio3_wakeup_gps_ap = <199>;
				gpio3_wakeup_gps_sh = <1006>;
				status = "ok";
			};
		};
	};

	&gps_power {
		status = "ok";
		batching,channel_type = "sensorhub";
	};

	&sensorhub_ext_config {
		adapt_sensor_list_id = <2 6 7 8 11 12 13 14 15 16 17 18 21 25 26 27 29 30 40>;
		hall_sen_type = <2>;
		adapt_file_id = <14 15 18 28 126>;
		acc_sensor_id = "1 65558";// acc:1;  acc1:65558:65558=0x10016
		gyro_sensor_id = "4 65559";// gyro:4; gyro1:65559:65559=0x10017
		mag_sensor_id = "2 65570";// mag:2; mag1:65570:65570=0x10022
		cap_sensor_id = "65572";// cap:65541:65541=0x10005; cap1:65572:65572=0x10024
	};

	&sensorhub_io_power{
		compatible = "huawei,sensorhub_io";
		sensor-io-supply = <&ldo24>;
		lsensor-io-supply = <&ldo12>;
		use_ldo12 = <0>;
		status="ok";
	};


	&hall {
		compatible = "huawei,hall_sensor,ak8789";
		status = "ok";
		huawei,hall_0{
			huawei,single-n-pole = <&gpio24 3 0>;/*195*/
			huawei,type = <0x01>;
			huawei,default-state = "on";
			huawei,int-delay-time = <100>;
		};
		huawei,hall_1{
			huawei,single-n-pole = <&gpio24 5 0>;/*197*/
			huawei,id = <1>;
			huawei,type = <0x01>;
			huawei,wakeup-flag = <0x4000>;
			huawei,hw-wakeup-support = <0x03>;
			huawei,default-state = "on";
			huawei,x-coordinate = <0>;
			huawei,y-coordinate = <0>;
			huawei,int-delay-time = <100>;
		};
	};
	/*
		device check : the 0 means that it don't need to check;
			the 1 means that it check at board check and running test;
			the 2 means that it check at running test
	*/
	&devcheck {
		touch_panel = <2>;
		compass = <2>;
		g_sensor = <1>;
		gyroscope = <1>;
		nfc = <0>;
		dc_dc = <0>;
		tps = <1>;
		l_sensor = <2>;
		charge_loadswitch = <1>;
		charge = <1>;
		usb_switch = <0>;
		wifi = <1>;
		bt = <1>;
		gps = <1>;
		antenna_ctl = <0>;
		airpress = <1>;
		vibrator_lra = <0>;
		laser = <0>;
		status = "ok";
	};

	&huawei_hisi_isp200 {
		hisi,is_fpga = <0>;
	pinctrl-names = "default", "idle";
	pinctrl-0 = <
		&gpio020_pmx_func
		&gpio021_pmx_func
		&gpio022_pmx_func
		&gpio023_pmx_func
		&gpio024_pmx_func
		&gpio025_pmx_func
		&gpio026_pmx_func
		&gpio027_pmx_func
		&gpio028_pmx_func
		&gpio012_pmx_func

		&gpio020_cfg_func
		&gpio021_cfg_func
		&gpio022_cfg_func
		&gpio023_cfg_func
		&gpio024_cfg_func
		&gpio025_cfg_func
		&gpio026_cfg_func
		&gpio027_cfg_func
		&gpio028_cfg_func
		&gpio012_cfg_func
		>;
	pinctrl-1 = <
		&gpio020_pmx_idle
		&gpio021_pmx_idle
		&gpio022_pmx_idle
		&gpio023_pmx_idle
		&gpio024_pmx_idle
		&gpio025_pmx_idle
		&gpio026_pmx_idle
		&gpio027_pmx_idle
		&gpio028_pmx_idle
		&gpio012_pmx_idle

		&gpio020_cfg_idle
		&gpio021_cfg_idle
		&gpio022_cfg_idle
		&gpio023_cfg_idle
		&gpio024_cfg_idle
		&gpio025_cfg_idle
		&gpio026_cfg_idle
		&gpio027_cfg_idle
		&gpio028_cfg_idle
		&gpio012_cfg_idle
		>;
	status = "ok";
	};

	&hisi_camera {
		hisi,is_fpga = <0>;
	};

	&huawei_hisi_fd {
		compatible = "hisilicon,hisi-fd";
		reg = <0x0 0xE8340000 0x0 0x20000>,    //FD reg
		      <0x0 0xE8320000 0x0 0x20000>,    //smmu reg
		      <0x0 0xE8303000 0x0 0x1000>;     //smmu master reg
		      huawei,top-base = <0xE8304000 0x1000>;
		hisi-fd-supply = <&ispsubsys>;
		hisi-media-supply = <&media1_subsys>;
		clocks = <&clk_gate_fd_func &clk_gate_jpg_func>;
		clock-names = "clk_fd_func", "clk_jpg_func";
		clock-value = <384000000>;
		clock-low-frequency = <277000000>;
		interrupts = <0 307 4>;
		huawei,smmu-flag = <1>;
		huawei,ram-config = <1>;
		smmu_offset_list = <0x10 0x1c 0x20 0x204 0x20c 0x220 0x224>;
		mstr_offset_list = <0x28 0x34 0x100 0x260 0x3c0>;
		fd_offset_list = <0x418 0x40c 0x410 0x414 0x464 0xFD 0x7A 0x9F 0x58 0x31c 0x470>;
		status = "ok";
	};

	&huawei_imx600imx351hybrid {
		compatible = "huawei,sensor";
		huawei,sensor_name = "IMX600IMX351HYBRID";
		huawei,sensor_index = <0>;
		huawei,is_fpga = <0>;
		huawei,pd_valid = <1>;
		huawei,reset_valid = <1>;
		huawei,vcmpd_valid = <0>;
		huawei,csi_index = <0 2>;
		huawei,i2c_index = <0 2>;
		/*cdphy-csi2*/
		huawei,phyinfo_valid = <2>;
		huawei,is_master_sensor = <1 0>;
		huawei,phy_id = <0 2>;
		huawei,phy_mode = <1 0>;
		huawei,phy_freq_mode = <1 0>;
		huawei,phy_freq = <80000000 80000000>;
		huawei,phy_work_mode = <0 0>;
		clocks = <&clk_gate_rxdphy0_cfg &clk_gate_rxdphy2_cfg &clk_gate_isp_snclk0 &clk_gate_isp_snclk2>;
		clock-names = "clk_rxdphy0_cfg", "clk_rxdphy2_cfg", "clk_isp_snclk0", "clk_isp_snclk2";
		huawei,phyclk = <80000000>;
		phy-clock-num = <2>;
		huawei,mclk = <19200000>;
		dvdd-supply = <&ldo32>;
		iovdd-supply = <&ldo21>;
		huawei,ldo-names = "dvdd", "iovdd";

		gpios = <&gpio1 4 0 &gpio6 4 0 &gpio17 0 0>;
		huawei,gpio-ctrl-types = "reset", "reset2", "vcm_pwdn";

		huawei,cam-power-seq-type = "sensor_pmic", "sensor_pmic", "sensor_pmic", "sensor_pmic",
		"sensor_dvdd", "sensor_vcm_pwdn", "sensor_iovdd",
		"sensor_mclk", "sensor_mclk",
		"sensor_rst", "sensor_rst2";
		huawei,cam-power-seq-cfg-val = <2850000 2800000 2800000 1800000 1100000 0 1800000 0 0 0 0>;
		huawei,cam-power-seq-val = <5 0 1 2 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF>;
		huawei,cam-power-seq-sensor-index = <0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0 2 0xFF 0xFF>;
		huawei,cam-power-seq-delay = <0 0 0 0 0 1 0 1 1 1 1>;

		huawei,cam-power-down-seq-type ="sensor_rst2", "sensor_rst", "sensor_mclk", "sensor_mclk",
		"sensor_iovdd", "sensor_vcm_pwdn", "sensor_dvdd",
		"sensor_pmic", "sensor_pmic",
		"sensor_pmic", "sensor_pmic";
		huawei,cam-power-down-seq-cfg-val = <0 0 0 0 1800000 0 1100000 1800000 2800000 2800000 2850000>;
		huawei,cam-power-down-seq-val = <0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 2 1 0 5>;
		huawei,cam-power-down-seq-sensor-index = <0xFF 0xFF 2 0 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF>;
		huawei,cam-power-down-seq-delay = <1 1 1 1 0 1 0 0 0 0 0>;

		status = "ok";
	};

	&huawei_ov08a10 {
		compatible = "huawei,sensor";
		huawei,sensor_name = "OV08A10E";
		huawei,is_fpga = <0>;
		huawei,pd_valid = <1>;
		huawei,sensor_index = <4>;
		huawei,csi_index = <1>;
		huawei,i2c_index = <2>;
		huawei,reset_valid = <1>;
		/*cdphy-csi2*/
		huawei,phyinfo_valid = <1>;
		huawei,is_master_sensor = <1>;
		huawei,phy_id = <3>;
		huawei,phy_mode = <0>;
		huawei,phy_freq_mode = <0>;
		huawei,phy_freq = <80000000>;
		huawei,phy_work_mode = <0>;
		clock-names ="clk_rxdphy3_cfg", "clk_isp_snclk2";
		clocks = <&clk_gate_rxdphy3_cfg &clk_gate_isp_snclk2 >;
		huawei,mclk = <19200000>;
		huawei,rxdphyclk = <80000000>;
		huawei,phyclk = <80000000>;
		phy-clock-num = <1>;
		huawei,vcmpd_valid = <0>;
		dvdd-supply = <&ldo38>;
		iovdd-supply = <&ldo21>;
		huawei,ldo-names = "dvdd","iovdd";

		gpios = <&gpio1 6 0>;
		huawei,gpio-ctrl-types = "reset";


		/*AFVDD buck2 2.85v| OIS LDO4 2.8V| AVDD LDO3 2.8V | DVDD	GPIO196 |
		 * IOVDD LDO20*/
		huawei,cam-power-seq-type = "sensor_pmic", "sensor_pmic", "sensor_pmic", "sensor_dvdd",
		"sensor_iovdd","sensor_rxdphy_clk", "sensor_mclk", "sensor_rst";
		huawei,cam-power-seq-cfg-val = <2850000 2800000 2750000 1205000 1800000 0 0 0>;
		huawei,cam-power-seq-val = <5 1 3 0xFF 0xFF 0xFF 0xFF 0xFF>;
		huawei,cam-power-seq-sensor-index = <0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 2 0xFF>;
		huawei,cam-power-seq-delay = <0 0 0 0 0 1 1 1>;

		huawei,cam-power-down-seq-type ="sensor_rst", "sensor_mclk","sensor_rxdphy_clk",
		"sensor_iovdd", "sensor_dvdd", "sensor_pmic", "sensor_pmic",
		"sensor_pmic";
		huawei,cam-power-down-seq-cfg-val = <0 0 0 1800000 1205000 2750000 2800000 2850000>;
		huawei,cam-power-down-seq-val = <0xFF 0xFF 0xFF 0xFF 0xFF 3 1 5>;
		huawei,cam-power-down-seq-sensor-index = <0xFF 2 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF>;
		huawei,cam-power-down-seq-delay = <1 1 1 0 0 0 0 0>;

		status = "ok";
	};
	&huawei_imx600front {
		compatible = "huawei,sensor";
		huawei,sensor_name = "IMX600FRONT";
		huawei,sensor_index = <1>;
		huawei,is_fpga = <0>;
		huawei,pd_valid = <1>;
		huawei,reset_valid = <1>;
		huawei,vcmpd_valid = <0>;
		huawei,csi_index = <0>;
		huawei,i2c_index = <0>;
		/*cdphy-csi2*/
		huawei,phyinfo_valid = <1>;
		huawei,is_master_sensor = <1>;
		huawei,phy_id = <0>;
		huawei,phy_mode = <1>;
		huawei,phy_freq_mode = <1>;
		huawei,phy_freq = <80000000>;
		huawei,phy_work_mode = <0>;
		clocks = <&clk_gate_rxdphy0_cfg  &clk_gate_isp_snclk0>;
		clock-names = "clk_rxdphy0_cfg", "clk_isp_snclk0";
		huawei,phyclk = <80000000>;
		phy-clock-num = <1>;
		huawei,mclk = <19200000>;
		dvdd-supply = <&ldo32>;
		iovdd-supply = <&ldo21>;
		huawei,ldo-names = "dvdd", "iovdd";

		gpios = <&gpio1 4 0 &gpio17 0 0>;
		huawei,gpio-ctrl-types = "reset","vcm_pwdn";

		huawei,cam-power-seq-type = "sensor_pmic", "sensor_pmic",
		"sensor_dvdd", "sensor_vcm_pwdn", "sensor_iovdd",
		"sensor_mclk", "sensor_mclk",
		"sensor_rst";
		huawei,cam-power-seq-cfg-val = <2850000 2800000 1100000 0 1800000 0 0 0 >;
		huawei,cam-power-seq-val = <5 0 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF>;
		huawei,cam-power-seq-sensor-index = <0xFF 0xFF 0xFF 0xFF 0xFF 0 2 0xFF>;
		huawei,cam-power-seq-delay = <0 0 0 1 0 1 1 1>;

		huawei,cam-power-down-seq-type ="sensor_rst", "sensor_mclk", "sensor_mclk",
		"sensor_iovdd", "sensor_vcm_pwdn", "sensor_dvdd",
		"sensor_pmic", "sensor_pmic";
		huawei,cam-power-down-seq-cfg-val = <0 0 0 1800000 0 1100000 2800000 2850000>;
		huawei,cam-power-down-seq-val = <0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0 5>;
		huawei,cam-power-down-seq-sensor-index = <0xFF 2 0 0xFF 0xFF 0xFF 0xFF 0xFF>;
		huawei,cam-power-down-seq-delay = <1 1 1 0 1 0 0 0>;

		status = "ok";
	};

	&huawei_imx316v{
		compatible = "huawei,sensor";
		huawei,sensor_name = "IMX316T";
		huawei,sensor_index = <2>;/*2 moca*/
		huawei,is_fpga = <0>;
		huawei,pd_valid = <1>;
		huawei,reset_valid = <1>;
		huawei,vcmpd_valid = <0>;
		huawei,csi_index = <0>;
		huawei,i2c_index = <1>;
		/*cdphy-csi2*/
		huawei,phyinfo_valid = <1>;
		huawei,is_master_sensor = <1>;
		huawei,phy_id = <1>;
		huawei,phy_mode = <0>;
		huawei,phy_freq_mode = <0>;
		huawei,phy_freq = <80000000>;
		huawei,phy_work_mode = <0>;//dphy use single
		clock-names = "clk_rxdphy0_cfg", "clk_rxdphy1_cfg", "clk_rxdphy2_cfg", "clk_rxdphy3_cfg", "clk_isp_snclk1";
		clocks = <&clk_gate_rxdphy0_cfg &clk_gate_rxdphy1_cfg &clk_gate_rxdphy2_cfg &clk_gate_rxdphy3_cfg &clk_gate_isp_snclk1>;
		huawei,mclk = <19200000>;
		huawei,rxdphyclk = <80000000>;
		huawei,phyclk = <80000000>;
		phy-clock-num = <4>;
		dvdd-supply = <&ldo38>;
		iovdd-supply = <&ldo21>;
		huawei,ldo-names = "dvdd","iovdd";
		gpios = <&gpio29 3 0 &gpio29 2 0 &gpio1 2 0>;
		huawei,gpio-ctrl-types = "dvdd1-en", "vcm_pwdn", "reset";
		huawei,cam-power-seq-type =
			"sensor_pmic",
			"sensor_iovdd",
			"sensor_dvdd",
			"sensor_dvdd1_en",
			"sensor_vcm_pwdn",
			"sensor_mclk",
			"sensor_rst";
		huawei,cam-power-seq-cfg-val = <2750000 1800000 1205000 0 0 0 0>;
		huawei,cam-power-seq-val = <3 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF>;
		huawei,cam-power-seq-sensor-index = <0xFF 0xFF 0xFF 0xFF 0xFF 1 0xFF>;
		huawei,cam-power-seq-delay = <0 0 0 1 1 1 1>;

		huawei,cam-power-down-seq-type =
			"sensor_rst",
			"sensor_mclk",
			"sensor_vcm_pwdn",
			"sensor_dvdd1_en",
			"sensor_dvdd",
			"sensor_iovdd",
			"sensor_pmic";
		huawei,cam-power-down-seq-cfg-val = <0 0 0 0 1205000 1800000 2750000>;
		huawei,cam-power-down-seq-val = <0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 3>;
		huawei,cam-power-down-seq-sensor-index = <0xFF 1 0xFF 0xFF 0xFF 0xFF 0xFF>;
		huawei,cam-power-down-seq-delay = <1 1 1 1 0 0 0>;

		status = "ok";
	};
	&fingerprint {
		compatible = "fpc,fingerprint";
		spi-max-frequency = <5000000>;
		fingerprint,product = "tahiti";

		fingerprint,navigation_adjust1 = <0>;
		fingerprint,navigation_adjust2 = <0>;

		fingerprint,fpc2050 = <1>;
		fingerprint,reset_gpio = <238>;
		fingerprint,irq_gpio = <237>;
		fingerprint,cs_gpio = <217>;
		fingerprint,power_en_gpio = <222>;
		fingerprint,spi_num = <2>;
		fingerprint,force_storage_type = <1>;
		fingerprint,extern_ldo_name = "EXTERN_LDO";
		fingerprint,extern_ldo_num = <34>;
		fingreprint_ldo-supply = <&ldo34>;
		fingerprint,extern_vol = <3300000>;
	};

    /*hisi power*/
    &hi110x {
        hi110x,subchip_type="hi1103";
        hi110x,gpio_power_on = <&gpio32 2 0>;                /*GPIO_258*/
        hi110x,gpio_bfgx_power_on = <&gpio25 2 0>;           /*GPIO_202*/
        hi110x,gpio_wlan_power_on = <&gpio25 0 0>;           /*GPIO_200*/
        hi110x,gpio_ssi_clk  = <&gpio33 1 0>;                /*GPIO_265*/
        hi110x,gpio_ssi_data = <&gpio33 2 0>;                /*GPIO_266*/
        huawei,pmu_clk32b = "clk_pmu32kb";
        hi110x,asic_version;
    };

    /*hisi wifi*/
    &hisi_wifi {
        hi110x,gpio_wlan_wakeup_host =  <&gpio25 3 0>;       /*GPIO_203*/
        hi110x,gpio_host_wakeup_wlan =  <&gpio32 7 0>;       /*GPIO_263*/
    };

    /*hisi bfgx*/
    &hisi_bfgx {
        hi110x,gpio_bfgx_wakeup_host = <&gpio25 6 0>;      /*GPIO_206*/
        hi110x,uart_port = "/dev/ttyAMA4";
        hi110x,uart_pclk_normal;
    };

    /*hisi customize*/
    &hisi_cust_cfg {
        ini_file_name = "/vendor/etc/cfg_tahiti_tugl_v1.ini";
    };

    /*hisi gps*/
    &hisi_gps {
        clocks = <&clk_gate_gps_ref>, <&clk_mux_gps_ref>, <&clk_gate_mdm2gps0>, <&clk_gate_mdm2gps1>, <&clk_gate_mdm2gps2>;
        clock-names = "ref_clk", "mux_clk", "mdm_clk0", "mdm_clk1", "mdm_clk2";
        /*hisi gps iomux config*/
        pinctrl-names = "default", "idle";
        pinctrl-0 = <&gpio248_pmx_func &gpio248_cfg_func>;
        pinctrl-1 = <&gpio248_pmx_idle &gpio248_cfg_idle>;
    };

    /*hisi gps sync*/
    &hisi_gps_sync {
        version = <1>;
        /*sync register configuration*/
        addr_base = <0xfff11000>;
        addr_offset = <0x0b8>;
    };

    &irda {
        compatible = "irda,config";
        irda,chiptype = <3>; /*hi64xx*/
    };

	/*nfc*/
	&nfc_exist {
		nfc_exist_flag = "1";
		hisee_exist_flag = "1";
		nfc_dbc_not_test_flag = "1";
		status = "ok";
	};



&spmi {
    pmic@0 {
        sim0 {
            status = "ok";
            det_normal_direction = "closed";
            allocate_gpio = <0>;
            shared_det_irq = <1>;
            card_tray_style = <1>;
            det_high_debounce_wait_time = <400>;
            det_low_debounce_wait_time = <300>;
            factory_send_msg_to_cp = <1>;
            mux_sdsim = <0>;
            pmu_ldo12_pull_down = <0>;
        };

        sim1 {
            status = "ok";
            det_normal_direction = "closed";
            allocate_gpio = <0>;
            shared_det_irq = <1>;
            card_tray_style = <1>;
            det_high_debounce_wait_time = <400>;
            det_low_debounce_wait_time = <300>;
            factory_send_msg_to_cp = <1>;
            mux_sdsim = <1>;
            pmu_ldo12_pull_down = <0>;
        };
    };
};

/*huawei vibrator*/
&vibrator_hw_config {
    compatible = "huawei,hw_vibrator";
    status = "ok";
};
